![image69](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/d6f17bc9-b7ee-4371-89f0-38bd272beb0c)# RAJKIT-MALWARE-DRIVER-USER

WRITE: [rajkit_.pdf](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/files/12593421/rajkit_.pdf)



![Captura de pantalla 2023-09-01 a las 16 20 09](https://github.com/kdRajKit/RAJKIT-MALWARE/assets/108155637/9d86de6d-8daa-416b-aeff-1ac53a16523f)

<div>

<span class="c1"></span>

</div>

<span class="c3 c103">TÉCNICAS AVANZADAS EN EVASIÓN DETECCIÓN DE SISTEMAS VIRTUALIZADOS y EVASIÓN DE AV/EDR´s</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c3">Alumno:</span><span> </span><span class="c12">RajKit</span>

<span class="c3">Tutor:</span><span class="c12"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 271.67px; height: 271.67px;">![image77](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/2d2ebe8c-91cd-48b7-8a54-99221e797368)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">TABLA DE CONTENIDO:</span>

<span class="c1"></span>

*   <span class="c1">INTRODUCCIÓN         </span>
*   <span class="c1">METODOLOGÍA</span>
*   <span class="c1">RAJKIT MALWARE</span>
*   <span>REDUCCIÓN DE LA ENTROPÍA -----------------------------------------------------------------{</span><span class="c3">7-10</span><span class="c1">}</span>
*   <span>DETECCIÓN DE VIRTUALIZACIÓN -------------------------------------------------------------{</span><span class="c3">11</span><span class="c1">}</span>

*   <span>Máquina virtual ------------------------------------------------------------------------{</span><span class="c3">12-15</span><span class="c1">}</span>
*   <span>Kernel exception hooking parte 1 -------------------------------------------------{</span><span class="c3">16-17</span><span class="c1">}</span>
*   <span>VlsVenabled -----------------------------------------------------------------------------{</span><span class="c3">18</span><span class="c1">}</span>
*   <span>Ataque de canal lateral de caché --------------------------------------------------{</span><span class="c3">18-20</span><span class="c1">}</span>
*   <span>Detección de anomalías respecto a las especificaciones del fabricante –{</span><span class="c3">20-23</span><span class="c1">}</span>

*   <span>SYSCALL DIRECT CALLING-----------------------------------------------------------------------{</span><span class="c3">24-27</span><span class="c1">}</span>

*   <span>NTDLL.DLL BASE desde PEB---------------------------------------------------------{</span><span class="c3">28-30</span><span class="c1">}</span>
*   <span>Direccion de funciones desde EAT ------------------------------------------------{</span><span class="c3">30-31</span><span class="c1">}</span>
*   <span>Obtener SYSCALL ----------------------------------------------------------------------{</span><span class="c3">32-34</span><span class="c1">}</span>

*   <span>DLL HOLLOWING</span> <span class="c12">“MODULE OVERLOADING”</span><span> ---------------------------------------------{</span><span class="c3">34-36</span><span class="c1">}</span>

*   <span>Ejecución--------------------------------------------------------------------------------{</span><span class="c3">37</span><span class="c1">}</span>

*   <span>PTE REMAPPING---------------------------------------------------------------------------------{</span><span class="c3">37-38</span><span class="c1">}</span>

*   <span>Direcciones virtuales,físicas,paginación y bits de control----------------------------------------------------------------------------------{</span><span class="c3">38-43</span><span class="c1">}</span>
*   <span>Subversión de la memoria---------------------------------------------------------{</span><span class="c3">44-45</span><span class="c1">}</span>
*   <span>Driver-----------------------------------------------------------------------------------{</span><span class="c3">46</span><span class="c1">}</span>
*   <span>Fase 1-----------------------------------------------------------------------------------{</span><span class="c3">47-48</span><span class="c1">}</span>
*   <span>Fase 2-----------------------------------------------------------------------------------{</span><span class="c3">48-50</span><span class="c1">}</span>
*   <span>Fase 3-----------------------------------------------------------------------------------{</span><span class="c3">50-51</span><span class="c1">}</span>

*   <span>KERNEL EXCEPTION HOOKING PARTE 2---------------------------------------------------{</span><span class="c3">51-60</span><span class="c1">}</span>
*   <span>CONCLUSIÓN------------------------------------------------------------------------------------{</span><span class="c3">61</span><span class="c1">}</span>
*   <span>BIBLIOGRAFIA-----------------------------------------------------------------------------------{</span><span class="c3">62-63</span><span class="c1">}</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">ENUNCIADO-INTRODUCCIÓN:</span>

<span class="c1">El malware no desea ser detectado ni que su actividad sea descubierta. Es una carrera contra reloj en la que los creadores de malware invierten una gran parte de su tiempo: evitar la detección o posponer todo lo posible dicha eventualidad. Por otro lado, en el bando contrario estamos quienes tenemos como tarea justo lo contrario: discernir de la forma más rápida y fiable qué es lo que hace un código cuando este es ejecutado (ya sea en forma nativa o interpretada) No es una tarea sencilla: si se hace despacio y con calma se hace bien, pero tal vez ya sea demasiado tarde. Por el contrario, con prisas, podemos decidir sobre un mayor caudal de muestras (que llegan de forma incesante), pero corremos el riesgo de crear situaciones tanto de falsos positivos como, a veces empeorando la situación, falsos negativos. En esta carrera de obstáculos, es precisamente capital las técnicas que tienen por objeto detectar cuando un binario está siendo ejecutado en una máquina virtual. En el caso que alguna de estas contra-medidas que portan los ejecutables de positivo, el malware no se ejecutará o empleará rutinas de código que no efectúan ninguna operación sospechosa o trivial para, evidentemente, volar por debajo del radar del investigador. Es fundamental tener conocimiento de estas técnicas.</span>

<span class="c1">Con el constante avance en la capacidad por parte del hardware, con el tiempo los sistemas operativos han sido capaces de ir introduciendo poco a poco mitigaciones muy importantes, aprovechando esa capacidad extra de cómputo que proporciona el hardware, haciendo de esa forma viable el constante monitoreo de actividades sospechosas.</span>

<span class="c1">Por otra parte la virtualización tanto del hardware como del kernel aplican un extra de seguridad en muchos aspectos como contramedida al malware, sin embargo siguen existiendo muchas formas de evasión con las cuales en conjunto se puede llegar a realizar actividades maliciosas en los sistemas operativos actuales.</span>

<span class="c61 c12 c29">En este punto comprendemos que la mejor forma de detección es la evasión.</span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3">METODOLOGÍA:</span>

<span class="c1">Para realizar la investigación sobre la detección de entornos virtualizados y la evasión de sistemas de detección por parte del malware, se decide diseñar una pieza de malware en su fase de “loader” teniendo en cuenta todos los aspectos de dicha fase.</span>

<span>A lo largo de la investigación nos adentraremos en profundidad mediante</span> <span class="c12">reversing</span><span class="c1"> en cada una de las fases que se proponen para crear un hipotético malware evasor de AV/EDR y entornos virtualizados, con el cual seremos capaces de ocultar y evadir los monitoreos, consiguiendo llegar al núcleo.</span>

<span class="c8 c3"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">1\. RAJKIT MALWARE</span>

<span class="c1">Lo primero antes de adentrarnos en el reversing de las técnicas propuestas hago hincapié en la comprensión del comportamiento del diseño presentado en la figura 0-1, es necesario tener ciertos matices en cuenta para estudiar el contenido del trabajo:</span>

*   <span class="c1">Todo el diseño está probado en su totalidad en Windows 10 versión 1909.</span>

*   <span class="c1">El propósito de este loader es proteger a todas costa el payload de cualquier tipo de detección.</span>

*   <span>Se realiza el estudio de unas partes concretas del diseño total del loader, marcadas en el diagrama completo de</span> <span class="c3">RAJKIT</span><span class="c1"> mediante puntos azules:</span>

*   <span>Evasión de la detección de shellcode encriptada en un análisis estático por parte del software de detección mediante</span> <span class="c12">REDUCCIÓN DE LA ENTROPÍA</span>
*   <span class="c1">Detección de la virtualización</span>
*   <span>Evasión del monitoreo de las APIS nativas mediantes</span> <span class="c12">SYSCALL DIRECT CALLING</span>
*   <span>Ocultación mediante DLL HOLLOWING y el protector del análisis forense desde el DRIVER mediante</span> <span class="c12">PTE REMAPPING</span>
*   <span>Evasión del protector</span> <span class="c12">KERNEL PATCH PROTECTION</span><span class="c1"> para evadir al guardián del kernel y de las modificaciones realizadas desde el driver en Windows.</span>

*   <span class="c1">Los puntos amarillos son fases que no se explican pero se hace referencia desde aqui a repositorios probados,  que son necesarias para el correcto funcionamiento, en lo cuales entrarian los siguiente puntos:</span>

*   <span class="c1">Elevación de privilegios mediante UAC BYPASS, la técnica que propongo es la siguiente:</span>

*   <span class="c34 c59">[https://github.com/AzAgarampur/byeintegrity8-uac](https://www.google.com/url?q=https://github.com/AzAgarampur/byeintegrity8-uac&sa=D&source=editors&ust=1709480026259874&usg=AOvVaw31q39wvOuxF7XnXx1xBJa_)</span>

*   <span class="c1">Mapeo del driver en memoria post-elevación de privilegios mediante una técnica que hace una explotación en el driver iqvw64e.sys de INTEL.</span>

*   <span class="c34 c59">[https://github.com/TheCruZ/kdmapper](https://www.google.com/url?q=https://github.com/TheCruZ/kdmapper&sa=D&source=editors&ust=1709480026260292&usg=AOvVaw12VMF7h-04Z07oO1DK-phn)</span>

*   <span class="c1">Las técnicas no se programan en conjunto para un mejor análisis tanto del código como la técnica en sí de las mismas.</span>
*   <span>La comunicación con el</span> <span class="c12">command&control</span><span class="c1"> la cual se trata, se propone una conexión con google script desde el cual se realiza la gestión de datos con el servidor c&c de esta forma evitaríamos un monitoreo por parte de los sistemas de sniffing y proxys de conexiones sospechosas, ralentizando la obtención del dominio final.</span>

<span class="c1">Todos los códigos que se necesitan para probar cada aspecto que se trata a lo largo de la investigación se encuentran en el repositorio propio de github, divididos en carpetas de puntos y subpuntos de la misma forma en la que está estructurado el trabajo.</span>

<span class="c9 c3">[</span><span class="c34 c9 c3">[REPOSITORIO RAJKIT GITHUB](https://www.google.com/url?q=https://github.com/kiRajKit/RAJKIT&sa=D&source=editors&ust=1709480026260785&usg=AOvVaw1MOoUIBjmIRl3UMdUBAhxN)</span><span class="c9 c3">]</span>

<span>Con estos datos en mente, la propuesta</span> <span class="c3">RajKit</span><span class="c1"> se ve de la siguiente manera en cada una de sus fases de carga en el sistema mediante distintas evasiones:</span>

<a id="t.0b0e02a0ff97e43928d3364db7697ba72f66e748"></a><a id="t.0"></a>

<table class="c44">

<tbody>

<tr class="c14">

<td class="c84" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 685.00px; height: 485.33px;">![image79](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/e658f792-a676-4a45-bcf4-eb44f02ea2f7)
</span>

</td>

</tr>

<tr class="c14">

<td class="c84" colspan="1" rowspan="1">

<span class="c12 c29 c74 c77">Figura 0-1\. Diagrama de comportamiento de RajKit</span>

</td>

</tr>

</tbody>

</table>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3">2\. REDUCCIÓN DE LA ENTROPÍA</span>

<span class="c1">La entropía es una medida de aleatoriedad, esto es importante por que la entropía es un reflejo directo de lo que puede o debe contener un archivo dependiendo de su codificación, por lo tanto puede mostrar ilegitimidad en el contenido del mismo, generalmente el loader tiende a mantener cifrado su payload hasta el momento de su ejecución en el sistema para tratar de evadir los análisis estáticos.</span>

<span class="c1"></span>

<span class="c1">Lo que ocurre es que los datos comprimidos encriptados con un buen cifrado por lo general parecen bytes aleatorios lo que hace aumentar la entropía y desencadenar la puesta en cuarentena y un evento de seguridad en el EDR.</span>

<span class="c1">La entropía de la información fue propuesta por primera vez por Shannon y se refiere al valor esperado de la cantidad de información, entre un valor de 0 a 8, siendo 8 el máximo de entropía que significa que los datos son más uniformes de los esperados.</span>

<span class="c1"></span>

<span>En la siguientes dos gráficas presentamos el cálculo de la entropía de un portable ejecutable con su payload sin encriptar  y otro con el payload encriptado con el algoritmo</span> <span class="c3">RC4</span><span class="c1">, mostrando la entropía también por sección del PE:</span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span>Esta gráfica nos muestra la sección</span> <span class="c12 c3">.data</span><span class="c12"> </span><span>del portable ejecutable que va desde</span> <span class="c3">40-50</span><span> con una entropía de</span><span class="c3 c9"> 6.29456</span>

<span class="c23"></span>

<a id="t.ecf98790a92344c1d4c6a92e3e65704b3255b1a6"></a><a id="t.1"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 368.00px;">![image78](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/9f95b48a-63b2-4fc8-85bb-2543e4e3bea6)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 1-1\. Payload encriptado con RC4 de alta entropía</span>

</td>

</tr>

</tbody>

</table>

<span class="c23"></span>

<span class="c23"></span>

<span class="c23"></span>

<span class="c1"></span>

<span>En este caso en el que el payload lo tenemos sin encriptar nos muestra la sección</span><span class="c3"> </span><span class="c12 c3">.data</span><span>del portable ejecutable desde</span> <span class="c3">40-50</span><span>con una entropía de</span> <span class="c9 c3">5.51430</span><span class="c1">:</span>

<span class="c23"></span>

<a id="t.9425681451d8727fc0580e24d465e01883cd7800"></a><a id="t.2"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 368.00px;">![image81](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/9d12733a-af81-413b-9e1d-e9a243c72b73)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 1-2\. Payload sin encriptar</span>

</td>

</tr>

</tbody>

</table>

<span class="c23"></span>

<span>Esto se calcula en función de los datos del archivo, siendo H (</span><span class="c12">x</span><span>) la entropía de la información y p (</span><span class="c12">x</span><span class="c1">) la probabilidad que se genera:</span>

<span class="c1"></span>

![](images/image1.png)![](images/image1.png)![](images/image2.png)
![image2](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/4c157d70-82c9-42c6-8a4c-950d089d0134)

<span class="c29 c97"></span>

<span>En el caso de</span> <span class="c3">RajKit</span><span>se propone el conjunto como un instalador normal, sin embargo el payload en forma de shellcode que contendría la comunicación con el</span> <span class="c12">command&control</span><span> (</span><span class="c12">en RajKit únicamente se ejecutará una calculadora, pero para este ejemplo usamos un shellcode que inyecta un VNC en un proceso para realizar las pruebas de entropía</span><span class="c1">) si está cifrada con un algoritmo de cifrado RC4 lo que aumenta la aleatoriedad y podría hacer saltar las alarmas, para ello utilizamos un método para reducir esa entropía de la siguiente manera:</span>

<span class="c1"></span>

<span class="c47 c9 c12">Sabemos que el software normal suele tener una entropía de entre</span><span class="c9 c12 c3 c47">4.8</span> <span class="c47 c9 c12">y</span> <span class="c47 c9 c12 c3">7.2</span><span class="c47 c9 c12">, sin embargo y dependiendo del tamaño inicial del payload a integrar en el loader que diseño es realmente útil integrar una reducción de este tipo para esquivar los análisis.</span>

<a id="t.e1e25ebdea9310958e7ee8b5b0bb5369f85cee16"></a><a id="t.3"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 160.00px;">![image3](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/536e7348-7d53-45c3-b883-489dd4454598)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 1-3\. Reducción de la entropía mediante introducción de  patrones</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 428.40px; height: 203.53px;">![image84](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/5efb2248-6fc8-4783-b1c0-5fa614819742)
</span>

<span>Una vez terminada la reducción de entropía el payload aumenta en tamaño por los patrones introducidos, sin embargo obtenemos un reducción considerable para el tamaño inicial del shellcode nos muestra la sección</span> <span class="c12 c3">.data</span><span>del portable ejecutable desde</span> <span class="c3">40-60</span><span>con una entropía de</span> <span class="c9 c3">4.86912</span><span class="c1">:</span>

<a id="t.6857fc42c131f5c80cb3f756b8c7966632f252bd"></a><a id="t.4"></a>

<table class="c43">

<tbody>

<tr class="c14">

<td class="c83" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 547.07px; height: 311.00px;">![image82](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/da08e2d2-affb-45bd-8df7-b19d1dcaa793)
</span>

</td>

</tr>

<tr class="c14">

<td class="c83" colspan="1" rowspan="1">

<span class="c4">Figura 1-3\. Payload post-reducción de entropía</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c13 c3">3\. DETECCIÓN DE VIRTUALIZACIÓN</span>

<span class="c1">Existen varias formas que el malware actual integra en su código tratando de detectar un sistema virtualizado sobre todo para tratar de evadir los sandbox y así evitar un análisis de comportamiento de la pieza de malware y desarrollar una contramedida lo más eficiente y rápido posible.</span>

<span>Muchas de estas técnicas tienen una forma simple como contra-evasión y se pueden mitigar fácilmente con una buena configuración de dicho sistema virtualizado, iremos clasificándolas en función del tipo y nos centraremos después en el estudio realizado por nosotros en los métodos que decidí implementar en nuestro</span><span class="c12"> “Proof of concept”</span><span class="c1"> y consideramos más óptimos:</span>

<span class="c1"></span>

<span class="c1">Evasiones basadas en tiempo:</span>

*   <span class="c1">Bombas de tiempo</span>
*   <span class="c1">Uso de API´s de retraso</span>
*   <span class="c1">Parches para dormir</span>

<span class="c1">Evasiones basadas en comportamientos de usuario:</span>

*   <span class="c1">Application.RecentFiles.Count</span>
*   <span class="c1"> </span>

<span class="c1">Evasiones basadas en VM:</span>

*   <span class="c1">Verificación de recuento de núcleos</span>
*   <span class="c1">Comprobación de espacio en disco y memoria fisica</span>
*   <span class="c8 c3">Usando instrucciones específicas (CPUID)</span>
*   <span class="c1">Información de BIOS</span>
*   <span class="c1">Lista negra de geolocalización</span>

<span class="c1"></span>

<span>Una de las técnicas que integraremos es el manejo de la ejecución de CPUID invitado, CPUID es una instrucción que provoca incondicionalmente la salida de la</span> <span class="c12">Virtual Machine</span> <span class="c1">, se utiliza por que permite que el software descubra detalles del procesador.</span>

<span class="c1">También se usa para vaciar la canalización de los procesadores que no admiten instrucciones como RDTSCP y puedan usar CPUID+RDTSC y CPUID como barrera.</span>

<span>Pero antes de entrar en profundidad en la detección de hypervisor mediante el uso de</span> <span class="c12 c3">“ataques de canal lateral de caché”</span><span class="c12"> </span><span class="c1">vamos a ver como funciona un hypervisor, sus instrucciones de salida condicional y registros de control ya que entendemos que para el correcto funcionamiento de un hypervisor realmente necesitamos saber de antemano si ya existe una virtualización del sistema, ya que la virtualización anidada no es compatible en todos los sistemas.</span>

<span class="c1">Durante esta lectura trataremos este tema desde un contexto de privilegios tanto de RING3 como de RING0.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">3.1 Máquina Virtual</span>

<span class="c1">Tanto Intel como AMD admiten ambos la tecnología de virtualización en sus procesadores modernos, nosotros nos centraremos en la tecnología VT-x de Intel principalmente por que son los procesadores que más se utilizan.</span>

<span class="c1">Las extensiones de máquina virtual definen la compatibilidad a nivel de procesador para máquinas virtuales y se admiten dos clases principales de software:</span>

*   <span class="c1">Monitores de máquinas virtuales (VMM)</span>
*   <span class="c1">Software invitado</span>

<span class="c1">Nos centraremos en los conceptos básicos de la arquitectura de máquinas virtuales y las extensiones de máquinas virtuales (VMX) que admiten la virtualización del hardware del procesador para múltiples entornos de software, nos interesa el funcionamiento del VMX ya que el soporte para la virtualización se proporciona mediante una forma de operación del procesador denominada operación VMX, existen 2 tipos:</span>

*   <span class="c1">Root Operation</span>
*   <span class="c1">Non-root Operation</span>

<span class="c1">El comportamiento del procesador en la operación non-root de VMX está restringido y modificado para facilitar la virtualización. En lugar de su funcionamiento normal, determinadas instrucciones y eventos provocan salidas de VM a VMM.</span>

<span class="c1">Debido a que estas salidas de VM reemplazan el comportamiento normal, la funcionalidad del software en la operación non-root de VMX es limitada. Es esta limitación la que permite que VMM mantenga el control de los recursos del procesador.</span>

<span class="c1">No existe ningún bit visible en el software cuya configuración indique si un procesador lógico está en operación VMX no root.</span>

<span class="c1">Por lo tanto un VMM puede permitir evitar que el software invitado determine que se está ejecutando en una máquina virtual.</span>

<span class="c1">Pero cómo interactúa el software invitado con un VMM? se describe de la siguiente manera:</span>

*   <span class="c33 c9 c29">El software ingresa a la operación VMX al ejecutar una instrucción VMXON</span>
*   <span class="c9 c29 c33">El VMM puede tomar la acción adecuada a la causa de la salida de la VM y luego puede regresar a la máquina virtual mediante una entrada de VM.</span>
*   <span class="c33 c9 c29">El VMM puede decidir apagarse y dejar el funcionamiento de VMX, con la instrucción VMXOFF</span>

<a id="t.502183a7fc0926e9736e4827c901aa0ea0d1c87f"></a><a id="t.5"></a>

<table class="c72">

<tbody>

<tr class="c41">

<td class="c93" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 462.00px; height: 186.00px;">![image88](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/66202ad2-1dc0-4ced-a3de-0442ca147ead)
</span>

</td>

</tr>

<tr class="c14">

<td class="c93" colspan="1" rowspan="1">

<span class="c4">Figura 3-1\. Interacción entre VMM Y software invitado</span>

</td>

</tr>

</tbody>

</table>

<span>Para permitir estas interacciones primero se debe comprobar si el procesador dispone de un soporte para VMX y para que el software del sistema puede determinar si un procesador admite este tipo de operaciones mediante</span> <span class="c9 c3">CPUID</span> <span class="c1">con la siguiente consulta:</span>

<a id="t.4b5909a29a4728468f3af35e6de629f736d31c5e"></a><a id="t.6"></a>

<table class="c101">

<tbody>

<tr class="c102">

<td class="c64" colspan="1" rowspan="1">

<span class="c1"></span>

<span class="c3 c63">bool</span><span class="c30">VMX =</span> <span class="c67">false</span><span class="c30">;</span>

<span class="c30"></span> <span class="c99 c3">__asm</span><span class="c30"> </span>

<span class="c38 c30 c29">                XOR   EAX, EAX</span>

<span class="c38 c30 c29">                INC    EAX</span>

<span class="c38 c30 c29"></span>

<span class="c30">                </span><span class="c9 c3">CPUID</span>

<span class="c30">BT     ECX,</span> <span class="c3 c87">0x5</span>

<span class="c38 c30 c29">                JC     VMXTRUE</span>

<span class="c30 c29 c38">                VMXFALSE :</span>

<span class="c38 c30 c29">                JMP  NON</span>

<span class="c38 c30 c29">                VMXTRUE :</span>

<span class="c30">MOV VMX,</span> <span class="c3 c87">0x1</span>

<span class="c38 c30 c29">                NON :</span>

<span class="c38 c30 c29">                NOP</span>

<span class="c38 c30 c29">    }</span>

<span class="c38 c30 c29"></span>

<span class="c30"></span> <span class="c3 c99">return</span><span class="c30"> VMX;</span>

</td>

</tr>

</tbody>

</table>

<span class="c1">En este punto comprendemos mejor el funcionamiento básico de interacción y que tenemos unas operaciones que nos permiten obtener información del procesador con operaciones de bit, de forma sigilosa pudiendo evadir hooks en API´s del sistema.</span>

<span class="c1">El bit VMX se encuentra en el bit 13 del registro CR4 del procesador, el cual es posible de habilitar en función de la compatibilidad que previamente hemos obtenido desde RING3, sin embargo esta acción debemos realizarla desde el driver, pero porque nuestro procesador tiene tecnología VT-x y sin embargo no soporta VMX? y si obtenemos un fallo desde el driver al intentar habilitar ese bit? esto nos llevaría a deducir que nuestro procesador ya está realizando operaciones de virtualización?</span>

<span class="c1">Como ya hemos dicho al principio estamos realizando todo el proyecto bajo VMWARE con un Windows 10 en su versión 1909:</span>

<span class="c1">Tenemos el bit 13 de CR4 en 0 según nos muestra WINDBG:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 90.67px;">![image86](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/d567c8a3-3f74-476d-b7f0-0d645784777e)
</span>

<span>Para nuestro propósito utilizaremos un driver con una función en ensamblador que realiza la operación OR para que el bit este en 1:</span> <span class="c12">0x00000000003506f8</span> <span class="c12 c3">OR</span> <span class="c12">0x2000</span><span class="c12 c3"> =</span><span class="c9 c12 c3"> 0x3526f8</span>

<a id="t.2d4806321139c5154da770e1a04c4e80f06f9516"></a><a id="t.7"></a>

<table class="c96">

<tbody>

<tr class="c14">

<td class="c82" colspan="1" rowspan="1">

<span class="c38 c69 c3">PUBLIC AsmEnableVmxOperation</span>

<span class="c38 c29 c76">.code _text</span>

<span class="c1"></span>

<span class="c38 c69 c3">AsmEnableVmxOperation PROC PUBLIC</span>

<span class="c1">        PUSH RAX                                    </span>

<span class="c1">        XOR RAX, RAX                        </span>

<span class="c1">        MOV RAX, CR4</span>

<span>        OR RAX,</span><span class="c3">2000h</span><span>        </span><span class="c69">            </span>

<span class="c69">        </span><span class="c9 c3">MOV CR4, RAX</span><span class="c69">        </span>

<span class="c1">        POP RAX                            </span>

<span class="c1">        RET</span>

<span class="c38 c69 c3">AsmEnableVmxOperation ENDP</span>

<span class="c38 c69 c3">END</span>

<span class="c13 c3"></span>

</td>

</tr>

</tbody>

</table>

<span>Esto nos devuelve una excepción de instrucción privilegiada</span> <span class="c3">c0000096</span><span>al realizar la operación</span> <span class="c12 c3">MOV CR4,RAX</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 567.00px; height: 126.93px;">![image92](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/608d56df-0d81-4ece-985a-fa7f83cb46d8)
</span>

<span class="c13 c3"></span>

<span class="c1">Lo que ha ocurrido es que cuando se ejecuta una Máquina Virtual, algunas de sus instrucciones no se pueden ejecutar directamente por el procesador, principalmente porque estas instrucciones pueden interferir con el estado del MMV o del SO anfitrión, estas instrucciones se denominan instrucciones sensitivas.</span>

<span class="c1">Por lo tanto en este punto tendríamos una detección bastante precisa.</span>

<span class="c13 c3">3.1.1 KERNEL EXCEPTION HOOKING</span>

<span class="c1">Esto realmente podría implementarse de una forma eficiente y aunque no lo implementaremos aquí, sí que lo analizaré por encima.</span>

<span>El BSOD que desencadena termina con pantallazo azul, lo desencadena la rutina</span> <span class="c3">KeBugCheckEx</span><span> y todo empieza con el comienzo de una excepción en nuestro caso siguiendo esta secuencia(</span><span class="c12">existen más rutinas durante la secuencia</span><span class="c1">)</span>

<a id="t.e4b73ff1d550404d6e35fc1d3a0f65614187ad18"></a><a id="t.8"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 221.20px;">![image90](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/ea2b6221-7da0-4b28-95ce-5665ac6b1ada)
</span>

</td>

</tr>

<tr class="c98">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 2-1-1.1\. Rutinas en Secuencia de Excepción Generada</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span>Nos centraremos en el reversing de</span> <span class="c12">ntoskrnl.exe</span><span>a partir de</span> <span class="c12">KeBugCheck</span><span> y</span><span class="c3"> </span><span class="c12">KeBugCheck2</span><span>que comienza deshabilitando las interrupciones, guardando el contexto de la llamada y el estado del procesador para pasar directamente el control a</span> <span class="c12">KeBugCheck2</span><span>que finalmente pasaría a</span> <span class="c12">HAL.DLL</span>

<span class="c3 c67">call    </span><span class="c3">cs:__imp_</span><span class="c9 c3">HalReturnToFirmware</span>

<span class="c8 c3"></span>

<span>Una vez aquí y para poder enganchar la excepción, tenemos que obtener la dirección en la que se exporta, por suerte</span> <span class="c12">HalPrivateDisparchTable</span><span>esta en la sección</span> <span class="c12">.data</span><span>lejos de</span> <span class="c3">KPP</span><span>y obtendremos así la dirección de la tabla</span> <span class="c34 c59">[HALL_DISPATCH](https://www.google.com/url?q=https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/hal/hal_dispatch.htm&sa=D&source=editors&ust=1709480026280249&usg=AOvVaw1Dc4MNzXcwQn_88QnJdCVE)</span><span>que es la que contiene punteros a las funciones que implementa</span> <span class="c12">HAL.DLL</span>

<span class="c67 c3">mov</span> <span class="c3">rax, cs:</span><span class="c9 c3">HalPrivateDispatchTable</span>

<span class="c1"></span>

<span>Una vez accedido al puntero de</span> <span class="c12">HalPrepareForBugCheck</span><span>se realizará el</span> <span class="c12">hook</span> <span>para después obtener la dirección de retorno de</span> <span class="c12">KeBugCheck2</span><span>, obtener el contexto de la rutina interrumpida, continuar con la ejecución y en nuestro caso volver a deshabilitar el bit</span> <span class="c9 c3">VMX</span><span>del registro</span> <span class="c9 c3">CR4</span><span class="c1">, ya que el contexto nos lo devolverá con el bit activo.</span>

<a id="t.400f4065a32299fbce99c5e297bbcafc42b0a6af"></a><a id="t.9"></a>

<table class="c80">

<tbody>

<tr class="c14">

<td class="c51" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 492.00px; height: 233.40px;">![image91](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/897fbcee-032d-4ca6-9cbd-c1e0f5846c9c)
</span>

</td>

</tr>

<tr class="c14">

<td class="c51" colspan="1" rowspan="1">

<span class="c4">Figura 2-1-1.2\. Expection Hook</span>

</td>

</tr>

</tbody>

</table>

<span class="c1">La evasión de excepciones del kernel como punto extra, la trato en el punto 7 para salirnos del punto 2, realizó un reversing de la pila de llamadas junto con un análisis en IDA, para comprender después la técnica de Hooking ByePG.</span>

<span>Sin embargo esto es solo para comprender un poco el funcionamiento de la MMV y cómo afectan algunas acciones bajo la virtualización. Nuestra técnica se basa en la recopilación de información mediante</span> <span class="c9 c3">CPUID</span><span>y la posterior detección de anomalías de la unidad central de procesamiento respecto a las especificaciones del fabricante, ya que esta fase de detección en</span> <span class="c12">RajKit</span><span>se implementa con privilegios</span> <span class="c12">RING3.</span>

<span class="c13 c3">3.1.2 VslVsmEnabled</span>

<span>Haciendo reversing durante el estudio de ” Exception Hooking a KPP” a</span> <span class="c12 c3">KeBugCheck2</span><span>me di cuenta que una de las comprobaciones que realiza Windows durante el manejo de excepciones</span> <span class="c12">“pre-bsod”</span><span>es la cerciorarse de que no está</span> <span class="c12">Hyper-V</span><span>activo mediante este</span> <span class="c3">bool VslVsmEnabled:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 205.33px;">![image93](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/a7f148b9-6a5b-4afe-98d4-69bceccd1b60)
</span>

<span class="c13 c3">3.1.3 ATAQUE DE CANAL LATERAL DE CACHÉ</span>

<span>Lo primero es crear un buffer de memoria que abarque varias páginas, entonces</span> <span class="c3">rdstc</span><span class="c1"> es ejecutado especulativamente en lugar de acceso especulativo a memoria privilegiada y el resultado se utiliza para acceder a una determinada parte del buffer creado previamente.</span>

<span class="c1">Las páginas del buffer a las que se puede acceder durante la ejecución especulativa son limitadas, lo que permite discernir posteriormente los accesos especulativos reales de los errores aleatorios.</span>

<span>Tan pronto como se completa la función que contiene la ejecución especulativa, el número de página con el tiempo de acceso más bajo se agrega a las estadísticas todo el caché en la región de memoria se</span> <span class="c12">flushea (Cuando la cantidad de datos no escritos en el caché alcanza un cierto nivel, el controlador escribe periódicamente los datos almacenados en caché en una unidad.)</span>

<a id="t.357e60a8b9737d44cf0602e7cea6480b80571469"></a><a id="t.10"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 371.40px; height: 229.40px;">![image94](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/936971da-96ae-4538-9852-610bae084648)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 2-1-3.1\. Ejecución especulativa de RDTSC y acceso de memoria basado en su retorno</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<a id="t.8a3051237f0f091993f40e299d29c344d6f34a07"></a><a id="t.11"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.60px; height: 288.00px;">![image95](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/060db5d0-e884-4380-8bdd-12e3c91b6309)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 3-1-3.2\.  Activación de la especulación</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1">Para tener éxito se utilizan 10.000 ciclos para recopilar la información, se calcula el número de errores de la región esperada.</span>

<span>En VM con VMEXIT en</span> <span class="c12 c3">rdtsc</span><span class="c1"> habilitado, el porcentaje de tiempo que afectan a áreas no designadas oscila entre el 50% y 90% y en sistema nos virtualizados es del 1%.</span>

<span class="c1">El ataque utiliza ejecución especulativa para engañar a la CPU para revelar información sobre cómo se ejecuta rdtsc.</span>

<span>En un entorno no virtualizado se ejecutaría</span> <span class="c3">rdstc</span> <span class="c1">en la propia CPU y la CPU simplemente devolverá el contador.</span>

<span>En un entorno virtualizado donde el hypervisor establece el bit</span> <span class="c12">“RDTSC EXIT”</span><span>en</span> <span class="c3">IA32_VMX_PINBASED_CTLSMSR</span><span class="c1">, de hecho ejecutar es un cambio de contexto, lo que llevaría demasiado tiempo.</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 116.00px;">![image96](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/2daf8fa8-4a7e-4b4e-a343-68c92a6d408f)
</span>

<span class="c13 c3"></span>

<span class="c13 c3">3.2 DETECCIÓN DE ANOMALÍAS RESPECTO A LAS ESPECIFICACIONES DEL FABRICANTE</span>

<span>Esta técnica que implementamos se basa en  la obtención de ciertos datos del fabricante que integraremos en una base de datos</span> <span class="c12">sqlite</span><span>o</span> <span class="c12">tinydb</span><span>encriptada dentro de la pieza de malware para posteriormente una vez ejecutado el loader en la máquina virtual obtener el modelo de procesador mediante instrucciones de bit</span> <span class="c9 c3">CPUID</span><span>y por último mediante la API</span> <span class="c12 c3">GetLogicalProcessorInformation</span><span>obtendremos la información sobre los procesadores lógicos y hardware relacionado, accediendo a la estructura o estructuras devueltas</span> <span class="c34 c59">[SYSTEM_LOGICAL_PROCESSOR_INFORMATION](https://www.google.com/url?q=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-system_logical_processor_information&sa=D&source=editors&ust=1709480026283405&usg=AOvVaw0ac6Ee3daivIMmEV_Pdk6h)</span><span class="c1"> .</span>

<span>Esta API que hemos elegido es importante ya que después de realizar un barrido por los diferentes EDR´s del mercado no hemos obtenido un positivo en</span> <span class="c12">hooks</span><span>a la misma, lo que nos permitirá una libre consulta. En el</span> <span class="c12">capítulo 4</span><span class="c1"> de este trabajo entramos más en detalle y nombramos todas las API´s monitoreadas por este tipo de software.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">3.2.1 RECOPILACIÓN DE DATOS</span>

<span class="c1">Lo primero es ponernos en el contexto de un VMM VMware con un Windows 10 1909 y un procesador Intel Core i9-9880H , con el que se realizará la prueba.</span>

<span class="c1">Los datos tanto en la máquina como del fabricante que buscamos son los siguientes:</span>

*   <span class="c1">Número del procesador</span>

*   <span class="c1">CPU,LCPU</span>
*   <span class="c1">Capacidad total de caches L1,L2 y L3</span>

<span class="c1">Según Intel el procesador en cuestión, cuenta con las siguientes especificaciones dentro de los campos que precisamos:</span>

*   <span class="c3">Nº del procesador:</span> <span class="c1">i9-988H</span>
*   <span class="c3">CPU:</span> <span class="c1">8</span>
*   <span class="c3">LCPU:</span> <span class="c1">16</span>
*   <span class="c3">L1:</span> <span class="c1">64KB</span>
*   <span class="c3">L2:</span> <span class="c1">256KB</span>
*   <span class="c3">L3:</span> <span class="c1">16MB</span>

<span class="c1"></span>

<span class="c1">La máquina virtual con la que trabajamos tiene la siguiente arquitectura respecto a sus nucleos fisicos y lógicos que maneja el hypervisor:</span>

<a id="t.fac8cf4a80db58fe2c68118e01eaf8faf7f33c19"></a><a id="t.12"></a>

<table class="c73">

<tbody>

<tr class="c14">

<td class="c81" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 397.20px; height: 266.60px;">![image97](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/cd696c49-5bbc-4221-9e42-ae38788037bd)
</span>

</td>

</tr>

<tr class="c14">

<td class="c81" colspan="1" rowspan="1">

<span class="c4">Figura 3-2-1.1\. Arquitectura VM de pruebas</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1">Sabiendo todos los datos necesarios ahora debemos obtenerlos desde la máquina virtual para poder cruzarlos y obtener las anomalías que buscamos para realizar una detección precisa, como nota es necesario comentar que esta técnica sería inviable si nuestro hypervisor trabajase con una sola máquina con todas sus CPU físicas asignadas a la misma.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span>Para recopilar el nombre completo del modelo de CPU debemos ejecutar</span><span class="c9 c3"> CPUID</span><span class="c1"> con determinados valores en el registro EAX concretamente:</span>

*   <span class="c3">CPUID EAX</span><span> =</span><span class="c9 c3"> 0x80000002</span>
*   <span class="c3">CPUID EAX</span><span>=</span> <span class="c9 c3">0x80000003</span>
*   <span class="c3">CPUID EAX</span><span>=</span> <span class="c9 c3">0x80000004</span>

<span class="c1">Esto nos devuelve un total de 16 bytes en formato little-endian en los registros EAX, EBX, ECX, EDX, de tal forma que concatenando los nos debería devolver el procesador usado por la máquina:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 455.00px; height: 146.80px;">![image98](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/7f4325cc-d486-4596-ac79-a93594a11f3e)
</span>

<a id="t.080db29e5c56692443c2c4e1cd80095778e08af0"></a><a id="t.13"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 69.33px;">![image99](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/ff1eee90-0e48-4ca3-8074-dc0dbbe9a294)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 3-2-1.2\. Nombre Procesador mediante CPUID</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span>Para terminar la recopilación de datos y posterior comparación respecto a los datos del fabricante nos faltaría obtener, CPU/LPCU y CACHES para ello como hemos nombrado anteriormente nos valdremos de la API  </span><span class="c12 c3">GetLogicalProcessorInformation</span> <span>y para obtener el tamaño de las caché L1,L2 y L3</span> <span class="c34 c3 c59">[SYSTEM_LOGICAL_PROCESSOR_INFORMATION](https://www.google.com/url?q=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-system_logical_processor_information&sa=D&source=editors&ust=1709480026286159&usg=AOvVaw3dRpV3UItBPBy4r5YhEyKi)</span><span>tiene una subestructura</span> <span class="c34 c3 c59">[_CACHE_DESCRIPTOR](https://www.google.com/url?q=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-cache_descriptor&sa=D&source=editors&ust=1709480026286342&usg=AOvVaw0iS9LJ-Wk0qrxrenqRLeTA)</span><span class="c1">  en la que contiene un campo DWORD llamado SIZE.</span>

<span class="c1">Si ejecutamos nuestro código obtenemos la siguiente información:</span>

<a id="t.ac2a022405726a83b685b329b8c16b6c5ac8b8ed"></a><a id="t.14"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 116.00px;">![image100](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/f7590ccf-a3d0-41a3-816d-bb5cbacf443d)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 3-2-1.3\. Datos de las CPU/LCPU y CACHE L1,L2,L3</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1">La realidad es que nos está devolviendo 2 procesadores lógicos por núcleo, es decir estaría detectando 4 procesadores lógicos.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1">Con la información necesaria recopilada podemos empezar a cruzar los datos para encontrar anomalías y considerar después que estamos bajo un sistema virtualizado:</span>

<span class="c1"></span>

<a id="t.32a7a281dfd17dadc4151fdfd1b423d75d3b6b94"></a><a id="t.15"></a>

<table class="c72">

<tbody>

<tr class="c14">

<td class="c91" colspan="1" rowspan="1">

<span class="c13 c3">INFORMACIÓN DEL FABRICANTE</span>

</td>

<td class="c91" colspan="1" rowspan="1">

<span class="c13 c3">INFORMACIÓN MÁQUINA VIRTUAL</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<a id="t.66a5124c55d71731637b87134f7cd88d97d5d033"></a><a id="t.16"></a>

<table class="c72">

<tbody>

<tr class="c14">

<td class="c25" colspan="1" rowspan="1">

<span class="c13 c3">Nº del procesador</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c1">i9-988H</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c13 c3">Nº del procesador</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c1">i9-988H</span>

</td>

</tr>

<tr class="c14">

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c13 c3">CPU</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c38 c3 c57">8</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c13 c3">CPU</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c38 c3 c57">2</span>

</td>

</tr>

<tr class="c14">

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c13 c3">LCPU</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c38 c3 c57">16</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c13 c3">LCPU</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c38 c3 c57">2*2=4</span>

</td>

</tr>

<tr class="c14">

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c13 c3">L1</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c38 c3 c57">65536</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c13 c3">L1</span>

</td>

<td class="c25 c42" colspan="1" rowspan="1">

<span class="c38 c3 c57">32768</span>

</td>

</tr>

<tr class="c14">

<td class="c25" colspan="1" rowspan="1">

<span class="c13 c3">L2</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c1">262144</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c13 c3">L2</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c1">262144</span>

</td>

</tr>

<tr class="c14">

<td class="c25" colspan="1" rowspan="1">

<span class="c13 c3">L3</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c1">16777216</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c13 c3">L3</span>

</td>

<td class="c25" colspan="1" rowspan="1">

<span class="c1">16777216</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1">Podemos observar cómo de esta manera obtendremos una confirmación fiable de que el sistema en el que estamos ejecutando está bajo gestión de hardware de un hypervisor.</span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3">4\. SYSCALL DIRECT CALLING</span>

<span>Es bien sabido por los desarrolladores de malware que los software de detección simples y EDR´s actuales como</span> <span class="c12 c3">Crowdstrike, SentinelOne, Cylance, Sophos, Symantec, CarbonBlack,DeepInstick,Attivo</span><span class="c1"> monitorizan mediante hook´s las APIS sensibles que permiten ciertas acciones que consideran sospechosas.</span>

<span>Este tipo de monitorización se realiza dentro del flujo de ejecución nativo de Windows (Nt,Zw) que se encuentran en NTDLL.DLL la cual representa la última capa de abstracción antes de hacer</span> <span class="c12">SYSCALL</span><span class="c1"> y ceder el control al kernel:</span>

<a id="t.ea8a7c39c2f66da42a99c3ba39f2068ac1109d93"></a><a id="t.17"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 493.00px; height: 125.00px;">![image67](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/695a8563-a6d9-4afd-8e8b-a0bd7f418281)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4-1\. Flujo de ejecución nativo sin monitorización EDR</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1"></span>

<span>Podemos seguir ese flujo de ejecución de</span> <span class="c12 c3">VirtualAllocEx</span><span>sin HOOK por EDR a través de IDA hasta llegar a su SYSCALL, empezando por</span> <span class="c12">kernel32.dll</span> <span class="c1">:</span>

<a id="t.496495ad5c164d782a058c1f779c259affa3a4d1"></a><a id="t.18"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 177.33px;">![image68](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/db961fc3-318d-4049-8e38-c2d475eb0d1b)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4-2\. Apuntando a KERNELBASE.DLL</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<a id="t.82f0ae402bd1c9f790fd0fb7fe391da7254c13de"></a><a id="t.19"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 133.33px;">![image69](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/f3ea773a-be31-44b4-b67d-609013d3216e)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4-3\. Apuntando desde KERNELBASE a ZwAllocateVirtualMemory</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<a id="t.f0a3abb2d0f9c6e0b7135bc023064bb3dc5660ad"></a><a id="t.20"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 96.00px;">![image70](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/2c73be69-9566-4ebd-bef9-30abbd68a7c2)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4-4\. Registro apuntador en NTDLL llegando a SYSCALL</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1">Como podemos observar en la secuencia de ejecución todas las APIS serán interceptadas y darán un aviso por parte del software de detección.</span>

<span class="c1">Para tener mayor conocimiento sobre cuales, después de investigar e ido obteniendo las API´s que monitorean todos los EDR´s actuales del mercado y los vuelco en esta lista:</span>

<a id="t.14d6186309b78921026ab4c0479aff38f9658177"></a><a id="t.21"></a>

<table class="c7">

<tbody>

<tr class="c92">

<td class="c68" colspan="1" rowspan="1">

<span class="c8 c3">KiUserApcDispatcher</span>

<span class="c8 c3">LdrLoadDll</span>

<span class="c8 c3">NtAllocateVirtualMemory</span>

<span class="c8 c3">NtAlpcConnectPort</span>

<span class="c8 c3">NtFreeVirtualMemory</span>

<span class="c8 c3">NtMapViewOfSection</span>

<span class="c8 c3">NtProtectVirtualMemory</span>

<span class="c8 c3">NtQueueApcThread</span>

<span class="c8 c3">NtReadVirtualMemory</span>

<span class="c8 c3">NtSetContextThread</span>

<span class="c8 c3">NtUnmapViewOfSection</span>

<span class="c8 c3">NtWriteVirtualMemory</span>

<span class="c8 c3">RtlInstallFunctionTableCallback</span>

<span class="c8 c3">ZwAllocateVirtualMemory</span>

<span class="c8 c3">ZwAlpcConnectPort</span>

<span class="c8 c3">ZwFreeVirtualMemory</span>

<span class="c8 c3">ZwMapViewOfSection</span>

<span class="c8 c3">ZwProtectVirtualMemory</span>

<span class="c8 c3">ZwQueueApcThread</span>

<span class="c8 c3">ZwReadVirtualMemory</span>

<span class="c8 c3">ZwSetContextThread</span>

<span class="c8 c3">ZwUnmapViewOfSection</span>

<span class="c8 c3">ZwWriteVirtualMemory</span>

<span class="c8 c3">NtCreateProcess</span>

<span class="c8 c3">NtCreateProcessEx</span>

<span class="c8 c3">NtCreateThread</span>

<span class="c8 c3">NtCreateThreadEx</span>

<span class="c8 c3">NtCreateUserProcess</span>

<span class="c8 c3">NtQueueApcThreadEx</span>

<span class="c8 c3">NtSetInformationProcess</span>

<span class="c8 c3">ZwCreateProcess</span>

<span class="c3 c8">ZwCreateProcessEx</span>

<span class="c8 c3">ZwCreateThread</span>

<span class="c8 c3">ZwCreateThreadEx</span>

<span class="c8 c3">ZwCreateUserProcess</span>

<span class="c8 c3">ZwQueueApcThreadEx</span>

<span class="c8 c3">ZwSetInformationProcess</span>

<span class="c8 c3">NtLoadDriver is hooked</span>

<span class="c8 c3">NtMapUserPhysicalPages</span>

<span class="c8 c3">NtOpenProcess</span>

<span class="c8 c3">NtQuerySystemInformation</span>

<span class="c8 c3">NtOpenKey</span>

<span class="c8 c3">NtOpenKeyEx</span>

<span class="c8 c3">NtRenameKey</span>

<span class="c1"></span>

</td>

<td class="c68" colspan="1" rowspan="1">

<span class="c8 c3">NtSetInformationFile</span>

<span class="c8 c3">NtSetValueKey</span>

<span class="c8 c3">NtTerminateThread</span>

<span class="c8 c3">ZwCreateFile</span>

<span class="c8 c3">ZwCreateKey</span>

<span class="c8 c3">ZwDeleteFile</span>

<span class="c8 c3">ZwDeleteKey</span>

<span class="c8 c3">ZwDeleteValueKey</span>

<span class="c8 c3">ZwOpenFile</span>

<span class="c8 c3">ZwOpenKey</span>

<span class="c8 c3">ZwOpenKeyEx</span>

<span class="c8 c3">ZwRenameKey</span>

<span class="c8 c3">ZwSetInformationFile</span>

<span class="c8 c3">ZwSetValueKey</span>

<span class="c8 c3">ZwTerminateThread</span>

<span class="c8 c3">NtAlertResumeThread</span>

<span class="c8 c3">NtGetContextThread</span>

<span class="c8 c3">RtlCreateUserThread</span>

<span class="c8 c3">ZwAlertResumeThread</span>

<span class="c8 c3">ZwGetContextThread</span>

<span class="c8 c3">NtQuerySystemInformationEx</span>

<span class="c8 c3">NtResumeThread</span>

<span class="c8 c3">NtSetInformationThread</span>

<span class="c8 c3">NtTerminateProcess</span>

<span class="c8 c3">RtlAddVectoredExceptionHandler</span>

<span class="c8 c3">RtlGetNativeSystemInformation</span>

<span class="c8 c3">ZwLoadDriver</span>

<span class="c8 c3">ZwMapUserPhysicalPages</span>

<span class="c8 c3">ZwOpenProcess</span>

<span class="c8 c3">ZwQuerySystemInformation</span>

<span class="c8 c3">ZwQuerySystemInformationEx</span>

<span class="c8 c3">ZwResumeThread</span>

<span class="c8 c3">ZwSetInformationThread</span>

<span class="c8 c3">ZwTerminateProcess</span>

<span class="c8 c3">LdrOpenImageFileOptionsKey</span>

<span class="c8 c3">NtCreateSection</span>

<span class="c8 c3">ZwCreateSection</span>

<span class="c8 c3">NtCreateFile</span>

<span class="c8 c3">NtCreateKey</span>

<span class="c8 c3">NtDeleteFile</span>

<span class="c8 c3">NtDeleteKey</span>

<span class="c8 c3">NtDeleteValueKey</span>

<span class="c8 c3">NtOpenFile</span>

<span class="c1"></span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span>En este punto tenemos algunas opciones para tratar de evadir esto, podríamos obtener una copia de</span> <span class="c12">NTDLL.DLL</span><span class="c1"> desde el disco sin los HOOK´s de los EDR ya que se implantan en memoria en tiempo de ejecución una vez mapeada en memoria la librería, por lo tanto una opción inteligente sería sobreescribir la librería en nuestro proceso mapeando la copia del disco.</span>

<a id="t.f3d5a9c04ec3ddd2ceda6e6662c89e1cfa56023d"></a><a id="t.22"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 261.33px;">![image71](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/6c2e5fe8-cacc-442b-8164-bdaae9120ec5)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4-4\. Evasión de monitorización mediante sobrescritura de NTDLL</span>

<span class="c4"></span>

</td>

</tr>

</tbody>

</table>

<span>Sin embargo en</span> <span class="c3">RajKit</span><span class="c1"> voy hacer uso de una técnica que evita esta secuencia de ejecución de Windows y evade las capas de abstracción que tenemos hasta la instrucción SYSCALL, obteniendo en tiempo de ejecución la llamada al sistema asociada a la rutina nativa de la que queremos hacer uso.</span>

<span>Para ello lo que haremos será usar código</span><span class="c12">asm</span> <span class="c1">compilado dentro de nuestro binario actuando como una API de Windows, pero realizar esto sin ser detectado tiene cierta complejidad, en siguiente diagrama muestro un poco los paso que vamos a seguir con nuestra técnica en concreto, ya que se podría implementar de diferentes formas, pero esta es la óptima:</span>

<a id="t.899907c51c71c2da84db5528ba50b82c4a1be2c6"></a><a id="t.23"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 284.00px;">![image72](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/3e83db8a-74fc-4159-b864-07f5592e3f8d)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4-5\. Flujo de ejecución Syscall Direct Calling</span>

</td>

</tr>

</tbody>

</table>

<span class="c13 c3">4.1 NTDLL.DLL BASE DESDE PEB</span>

<span>Lo primero que tenemos que hacer es obtener la dirección base de la librería dinámica NTDLL, pero tendremos que hacerlo sin usar ninguna API, para ello tendremos que ir desde el</span> <span class="c12">Thread Environment Block (</span><span class="c34 c12 c3 c59">[TEB](https://www.google.com/url?q=https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb&sa=D&source=editors&ust=1709480026302354&usg=AOvVaw2xbUVCKh66MFPJOPoWvcQc)</span><span class="c12">)</span><span>al</span> <span class="c12">Process Enviroment Block (</span><span class="c34 c12 c3 c59">[PEB](https://www.google.com/url?q=https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb&sa=D&source=editors&ust=1709480026302691&usg=AOvVaw1skMn_nb1Tg9U8o9xHTtil)</span><span class="c12">)</span><span>y continuar escalando a través de las estructuras y listas enlazadas hasta</span> <span class="c3">DllBase</span><span class="c1">, como?</span>

<span class="c1"></span>

<a id="t.a9256af422be2ef9347b2a54d0f84fe70fc48d8d"></a><a id="t.24"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 289.07px;">![image73](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/843f5aa1-89f7-4677-8b23-b10686d16e4c)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4-6\. Dirección Base a través de Process Environment Block</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1">Como explico en el diagrama tendremos que recuperar la dirección de PPEB dentro de TEB para ello tendremos que acceder a través del registro GS para sistemas x64 en la compensación 0x60:</span>

<span class="c3 c65">PSW2_PEB</span><span class="c30"> Peb =(PSW2_PEB)__readgsqword(</span><span class="c3 c87">0x60</span><span class="c30">);</span>

<span class="c38 c30 c29"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 185.33px;">![image74](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/798d81cb-9d75-4c6c-8abd-34bb19cae1e1)
</span>

<span class="c38 c30 c29"></span>

<span class="c30">Desde PEB en el desplazamiento 0x18 tenemos</span> <span class="c30 c3">Ldr</span><span class="c30">del tiempo</span> <span class="c30 c12">_PEB_LDR_DATA</span><span class="c30">, accedemos:</span>

<span class="c38 c30 c29"></span>

<span class="c3 c65">PSW2_PEB_LDR_DATA</span><span class="c30">Ldr</span> <span class="c55">=</span><span class="c30"> Peb</span><span class="c55">-></span><span class="c30">Ldr;</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 224.00px;">![image75](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/19ef6f02-c7a0-47e3-8a02-6744c9b60752)
</span>

<span>Si volcamos</span> <span class="c12">_PEB_LDR_DATA</span><span> vemos en el desplazamiento 0x20 una lista</span><span class="c12"> _LIST_ENTRY</span><span> </span><span class="c3">InMemoryOrderModuleList</span> <span>que en realidad es el encabezado a una lista doblemente enlazada que entre otras cosas contiene los módulos cargados y su dirección base, lo que significa que tendremos que iterar todas las estructuras, es decir una estructura por cada módulo cargado hasta encontrar</span> <span class="c12">NTDLL.DLL</span><span class="c1">:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 415.13px; height: 55.00px;">![image76](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/5ee63a97-45e8-4bbe-8d24-a14df80acdca)
</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 49.33px;">![image13](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/b971418e-a276-42e0-b8c8-1ddc898bd6d8)
</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 96.00px;">![image14](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/1492cf08-1e4e-4700-ae8b-ed70b0ddf53a)
</span>

<span class="c1">En este punto ya tendríamos localizada NTDLL.DLL y su dirección base DllBase.</span>

<span class="c1"></span>

<span class="c13 c3">4.2 DIRECCIÓN DE FUNCIONES DESDE EAT</span>

<span>La</span> <span class="c12">EXPORT_ADDRESS_TABLE (EAT)</span><span>funciona como la</span> <span class="c12">IAT</span><span class="c1"> solo que la biblioteca exportará las funciones al ejecutable de la imagen, en el que el programa se importará al IAT.</span>

<span>Para ello tenemos que investigar la estructura de datos</span> <span class="c12">IMAGE_EXPORT_DIRECTORY</span><span>del formato PE y acceder al desplazamiento donde se encuentra</span> <span class="c12">AddressOfFunctions</span><span>, qué es el índice de todas las funciones,  utilizaremos la dirección base</span> <span class="c3">7ff9ad420000</span><span>de</span> <span class="c12">NTDLL.DLL</span><span class="c1"> como ejemplo, desde WINDBG se requiere seguir el siguiente diagrama de desplazamientos con alguna conversión a HEX por el camino:</span>

<a id="t.7424095aad30cee50e0f9fd4cf6c72aec07762ea"></a><a id="t.25"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 269.00px; height: 237.00px;">![image15](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/6bd95f96-b316-4cdd-a2ca-91cce708bf6a)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4.2-1\. Estructuras y desplazamientos hasta IMAGE_EXPORT_DIRECTORY</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span>Una vez en la estructura, a través de los desplazamiento de la</span> <span class="c12">VirtualAddress</span><span>de</span> <span class="c12">IMAGE_DATA_DIRECTORY</span><span class="c1"> tendríamos lo siguiente:</span>

*   <span class="c3">0x7FFFCD4A0000</span><span class="c9 c3">+0xD8+0x18+0x70+0x14c500</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 153.33px;">![image16](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/b72d7408-c018-46f2-8bd2-365e8a310503)
</span>

<span class="c3 c65 c89"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 82.67px;">![image17](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/6d53e423-c5e6-4e3e-a530-9785a52d2257)
</span>

<span class="c89 c30 c29"></span>

<span>Con esos 3 campos obtenidos, que son los que nos interesan de esa estructura tenemos que hacer un pequeño calculo por que cuando queremos obtener la dirección de una función en código mediante la API de Windows, realmente se obtiene buscando por ejemplo el nombre</span> <span class="c12">“</span><span class="c12 c21">AlpcFreeCompletionListMessage</span><span class="c12">”</span><span> en  </span><span class="c12">AddressOfNames</span> <span>del cual se extrae la posición en la matriz dentro de</span> <span class="c12">AddressOfNameOrdinals</span><span>que a su vez nos devuelve el índice de la función en</span> <span class="c12">AddressOfFunctions  </span><span>y esa dirección que obtenemos en realidad es una</span> <span class="c12">Relative Virtual Address (RVA)</span><span>que tendremos que sumar a la</span> <span class="c12">DllBase</span><span class="c1"> que obtuvimos previamente!</span>

<a id="t.d0825b07298e7639f58baa3133f597d9b6dbef56"></a><a id="t.26"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.13px; height: 212.13px;">![image18](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/01e77701-6fb4-48b9-b7d8-15afab1a7f41)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 4.2-2\. Obtención de RVA de AlpcFreeCompletionListMessage</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span>Mostramos en</span> <span class="c12">WINDBG</span><span class="c1"> el mismo proceso:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 583.87px; height: 108.00px;">![image19](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/8a57d453-f72f-4dcf-bcde-9eefe076756d)
</span>

<span class="c70 c3">DllBase</span><span>+</span><span class="c3 c70">AddresOfFunctions[AddressOfNames[</span><span class="c3 c100">AddressOfNameOrdinals</span><span class="c70 c3">]]</span><span class="c3"> </span><span>=</span> <span class="c9 c3">Dir. función</span>

<span class="c13 c3">4.3 OBTENER SYSCALL</span>

<span>En este último paso tenemos que extraer de las llamadas nativas su correspondiente SYSCALL, para ello se realiza una búsqueda de funciones que empiezan por</span> <span class="c12">Zw</span><span>y luego se crea una matriz de llamadas al sistema almacenando el nombre cambiado por</span> <span class="c12">Nt,</span> <span>de esta forma es más eficiente ya que no requiere verificar la presencia de</span> <span class="c12">Ntdll</span><span class="c1"> al comienzo del nombre.</span>

<span>Por lo general cada rutina de servicio del sistema nativo tiene 2 versiones parecidas con prefijo diferente y son atendidas por la misma rutina del sistema en modo kernel, mostramos como ejemplo:</span> <span class="c9 c12 c3">NtAllocateVirtualMemory</span><span>y</span> <span class="c9 c12 c3">ZwAllocateVirtualMemory</span> <span>comparten la SYSCALL</span> <span class="c9 c3">18</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 596.13px; height: 117.00px;">![image20](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/97805182-ef4c-49fc-a112-bc9a26142afd)
</span>

<span>Iremos iterando</span> <span class="c12">NumerOfNames</span><span class="c1"> en busca del prefijo para ir almacenando en la estructura un HASH del nombre para evadir análisis de EDR/AV.. junto con la dirección de la función.</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 393.33px; height: 142.00px;">![image21](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/a0f9ad67-880c-477f-b397-69c572f97b78)
</span>

<span class="c1">Lo bueno de esta técnica que implementa SysWhispers2 es que después ordena de forma ascendente esas direcciones y resulta que coincide también con la llamada correspondiente a su nombre!!</span>

<span class="c1">Genial porque de esa forma la llamada al sistema en nuestra matriz corresponderá a la posición del nombre dentro de esa matriz!</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 354.40px; height: 276.00px;">![image22](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/be57c2dc-247d-4247-b283-55aa10aaf0b2)
</span>

<span class="c13 c3">4.4 EJECUCIÓN</span>

<span class="c1">Por último nos quedaría manejar los registros del procesador y controlar el contexto de los registros para poder mantener los parámetros que requieren las funciones y mientras usar la función que nos devolverá la llamada al sistema que necesitamos, como?</span>

<span>Tenemos que tener en cuenta la convención de llamadas</span> <span class="c12">__fastcall</span> <span>x64 que utiliza determinados registros del procesador, en el caso de argumentos enteros son los registros</span> <span class="c3">RCX</span><span>,</span><span class="c3">RDX</span><span>,</span><span class="c3">R8</span><span>y</span> <span class="c3">R9</span><span class="c1"> y a partir del quinto se pushean al stack, por lo tanto primero guardaremos los registros que enviaron al llamar a nuestra propia rutina nativa:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 218.87px; height: 105.00px;">![image3](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/a93b37b5-cdba-4339-a27e-325302e83e19)
</span>

<span>Lo siguiente es preparar el registro</span> <span class="c3">ECX</span><span>con el HASH correspondiente a</span> <span class="c3">NtAllocateVirtualMemory</span><span>=</span> <span class="c9 c3">015882105h</span><span class="c1"> y llamar a la función propia:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 242.00px; height: 51.40px;">![image4](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/4c1f8bd2-6572-47bc-aca3-a07e9e82aefd)
</span>

<span class="c1">Volvemos a restaurar los registros:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 225.00px; height: 129.67px;">![image5](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/45ba329e-24cd-45bd-b4e8-fdab8f4471c0)
</span>

<span class="c1">Y por último invocar SYSCALL:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 253.00px; height: 64.93px;">![image6](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/aebecb1d-6359-460f-9197-ff890441efcf)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">5\. DLL HOLLOWING</span>

<span>En esta fase hablaremos de la sobre carga de módulos en un proceso dado, al cual despues se le inyectara una shellcode que se ejecutará como un</span> <span class="c12">thread  </span><span class="c1">de esta forma no se asignan páginas de memoria RWX ni se cambian sus permisos el proceso en ningún momento.</span>

<span class="c1">El código malicioso se inyecta en una DLL legítima de Windows por lo tanto se entorpece la detección, tanto por análisis estáticos como por sistemas de detección como los EDR/AV.</span>

<span class="c1">El thread con el código malicioso, está asociado con un módulo legítimo de Windows.</span>

<span class="c1"></span>

<a id="t.1e714d1f48ef5b52d949065a8e1d6ad891dc7a0b"></a><a id="t.27"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 458.93px; height: 162.87px;">![image7](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/162ba4de-22ba-4be8-9423-a7aa7bc5c83f)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 5-1\. DLL HOLLOWING “Sobrecarga de módulos”</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span>Para realizar esta operación y aunque nosotros no lo implementemos en el código, el diseño de nuestro malware requiere realizar las llamadas a API mediante la técnica descrita en el punto 4 del trabajo,</span> <span class="c12">syscal direct calling</span><span class="c1"> para evitar el monitoreo de EDR.</span>

*   <span class="c8 c3">OpenProcess</span>
*   <span class="c8 c3">LoadLibrary</span>
*   <span class="c8 c3">VirtualAllocEx</span>
*   <span class="c8 c3">WriteProcessMemory</span>
*   <span class="c8 c3">CreateThread</span>

<span>En este ejemplo realizaremos la inyección de la DLL benigna en un</span> <span class="c12">notepad.exe</span><span>, para comprender más fácil la técnica, pero en nuestro malware se propone hacerlo en el propio proceso de nuestra pieza de malware para después realizar la ocultación desde el driver</span> <span class="c12">RajKit.sys</span><span>desde la siguiente fase de</span> <span class="c3">PTE REMAPPING</span><span class="c1">.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1">Lo primero es obtener un manejador del proceso a través del ID:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 38.67px;">![image8](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/50dac984-1c64-4240-aabf-a2e0b00c160d)
</span>

<span class="c1">Cargamos la DLL benigna propia de la biblioteca de windows , system32:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 567.00px; height: 88.87px;">![image9](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/eb8246d1-c60b-4328-a95f-84eca6aeaae8)
</span>

<span>Buscamos el</span> <span class="c12">Base Address</span><span>del la dll inyectada en el proceso, para ello iteramos todos los módulos y simplemente comparamos con el nombre del modulo</span> <span class="c12">amsi.dll</span><span class="c1"> en hasta el acierto:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 193.33px;">![image10](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/14d68fe0-efb5-475d-986e-5fa525e4222b)
</span>

<span>Extraemos el</span> <span class="c12">AddressOfEntryPoint</span> <span>de la</span> <span class="c12">dll</span><span class="c1"> escalando a través de la estructura portable ejecutable:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 138.67px;">![image11](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/5be8dd84-c91f-4208-b278-10a6727e0734)
</span>

<span class="c1">Escribimos la shellcode en la memoria en el EntryPoint de la dll benigna para después crear un thread hacia el:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 66.67px;">![image12](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/d07aea93-2245-4184-a114-5d8f47920b5a)
</span>

<span class="c13 c3">5.1 EJECUCIÓN</span>

<span>Trazaremos la ejecución del programa en busca del contenido del thread en el modulo</span> <span class="c12">amsi.dll</span><span class="c1">, de tal forma que deberíamos obtener nuestra shellcode al volcar el thread del módulo benigno de windows:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 638.00px; height: 328.00px;">![image35](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/70d14a3d-0d95-402a-859f-67cead453d0d)
</span>

<span>Podemos observar como el</span> <span class="c12">EntryPoint</span><span>de la dll beigna</span> <span class="c12">amsi.dll</span><span class="c1"> contiene nuestra shellcode.</span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3">6\. PTE REMAPPING</span>

<span>Antes de entrar en esta técnica, es importante para el lector el planteamiento correcto del conjunto de la fase de</span> <span class="c12">“DLL HOLLOWING+PTE REMAPPING“</span> <span class="c1">, la implementación conjunta como bien se describe al principio del trabajo no se va llevar a cabo pero es indispensable para el lector conocer la propuesta, ya que no e visto ninguna implementación parecida que abarque este conjunto de técnicas.</span>

<span class="c1">Se propone de la siguiente manera:</span>

*   <span>Desde la fase</span> <span class="c12">“DLL HOLLOWING”</span><span>se copia</span> <span class="c9">0x1000</span><span>desde el</span> <span class="c12">EntryPoint</span><span> del código en memoria de  </span><span class="c9">amsi.dll</span> <span>en un espacio de memoria reservado previamente dentro de</span> <span class="c9">amsi.dll</span>
*   <span>Se inyecta la shellcode a partir del EntryPoint de</span> <span class="c9">amsi.dll</span> <span class="c1">en memoria</span>

<span class="c1">Fase de ocultación desde el driver:</span>

*   <span class="c1">Mediante la técnica que explico desde el punto 7.1, se modifican los pfn de las PTE que en realidad son las direcciones físicas reales de cada página de memoria, y se intercambian.</span>
*   <span class="c8 c29">De esta forma nuestro código quedaría oculto, cuando se haga un volcado del EntryPoint la traducción de direcciones virtuales a físicas, devolverá el volcado del EntryPoint original en lugar de la shellcode maligna.</span>

<a id="t.b40766c1ddbcdddb655778bcddba205e79cb38f2"></a><a id="t.28"></a>

<table class="c88">

<tbody>

<tr class="c14">

<td class="c86" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 505.00px; height: 281.33px;">![image36](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/e411d219-3577-49c5-94f0-957395dd057f)
</span>

</td>

</tr>

<tr class="c14">

<td class="c86" colspan="1" rowspan="1">

<span class="c4">Figura 6-1\. DLL HOLLOWING + PTE REMAPPING</span>

</td>

</tr>

</tbody>

</table>

<span class="c8 c29"></span>

<span class="c9 c3">IMPORANTE!!</span><span class="c3"> </span><span class="c12 c3">Por lo tanto no solo inyectamos el código en una dll benigna del propio sistema Windows, sino que además en un análisis forense de la misma ese código quedaría oculto aprovechando la propia traducción de direcciones virtuales a físicas que realiza el propio sistema.</span>

<span class="c13 c3"></span>

<span class="c13 c3">7.1 DIRECCIONES VIRTUALES, FÍSICAS, PAGINACIÓN Y BITS DE CONTROL</span>

<span class="c1">Todo lo que hacemos en este punto se basa en PAE, que se habilita a través de uno de los bits de control del registro CR4 del procesador, concretamente el sexto bit empezando de la derecha:</span>

<span class="c2"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 94.67px;">![image37](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/38e12c42-5e1d-46db-bb0c-cfa30aab37f5)
</span>

<span class="c1">Ahora pasemos a despiezar lo que conocemos como dirección virtual, que es lo que representa cada parte y como se accede desde la base de la tabla PML4 a través de la dirección de memoria física que contiene el registro CR3 a la diferentes estructuras principales de paginación para llegar a la PTE y obtener la dirección física de la página correspondiente:</span>

<span class="c2"></span>

<a id="t.5c8e2d40781098f2bc687f9f49f7973e4f5f7e60"></a><a id="t.29"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 288.00px;">![image38](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/d3cc3346-11ce-4eb3-a2de-8e2e75419160)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 6-1\.  Traducción Dirección Virtual a Dirección Física</span>

</td>

</tr>

</tbody>

</table>

<span class="c1">En el diagrama que e hecho se explica un poco el recorrido de la traducción, de tal forma que cada 9 bits desde el bit 47 se realiza un cálculo con el offset de la estructura de paginación y el registro de esa estructura se indexa para acceder a la siguiente estructura de paginación y terminar en la dirección física lineal correspondiente a esa dirección virtual lineal.</span>

<span class="c1">De esta forma tenemos 4 estructura de paginación responsables de esta traducción:</span>

*   <span class="c3">PML4</span><span>→ bits 47-39 →</span> <span class="c20 c3">2^9=512</span><span class="c1"> posibles indexaciones</span>
*   <span class="c3">PDPE</span><span>→ bits 38-30 →</span> <span class="c20 c3">2^9=512</span><span class="c1"> posibles indexaciones</span>
*   <span class="c3">PDE</span><span>→ bits 29-21 →</span> <span class="c20 c3">2^9=512</span><span class="c1"> posibles indexaciones</span>
*   <span class="c3">PTE</span> <span>→ bits 20-12 →</span> <span class="c20 c3">2^9=512</span><span class="c1"> posibles indexaciones</span>

<span class="c1">Con lo que terminaríamos obteniendo la dirección física de la página correspondiente la cual en 64BITS seria</span>

*   <span class="c9 c3">2^12</span><span>=</span><span class="c3">4096 bytes → 4K</span>

<span>Siempre y cuando en los bits de control de la estructura PDPTE no tengamos activado</span> <span class="c3">page_size</span><span class="c1">, lo que permitiría crear Large Pages de 1GB y cambiar un poco la transición de la traducción, ya que se prescinde de las PTE y se accedería directamente desde PDE</span>

<span>Visto muy por encima el proceso de traducción y antes de explicar la técnica que trataremos desde el driver vamos a pasar al Windbg que mediante un ejemplo obtendré los flags de control de una entrada</span> <span class="c3">PTE</span><span class="c1"> para modificarlo y ver qué ocurre, que en este caso será la shellcode que inyectamos en un espacio de direcciones reservado por nosotros, para ello tenemos este código:</span>

*   <span class="c3">VirutalAlloc →</span> <span class="c20">Reservamos espacio con permisos</span> <span class="c20 c3">0x40</span><span class="c20"> (PAGE_EXECUTE_READWRITE)</span>
*   <span class="c3">MoveMemory →</span><span class="c20 c3"> </span><span class="c20">[payload] ('\x90')</span>
*   <span class="c3">VirtualProtect →</span><span class="c20 c3"> </span><span class="c20">Cambiamos permisos a solo lectura → (PAGE_READONLY)</span>
*   <span class="c3">MoveMemory →</span><span class="c3 c20"> </span><span class="c20">[payload2] ('\x00')</span>

<span>Por lo tanto cambiaremos los permisos mediante la modificación del bit de control</span> <span class="c3">R/W</span><span>de la PTE correspondiente a las entradas de página de la dirección virtual del espacio reservado, para permitir</span> <span class="c3">RtlMoveMemory()</span><span class="c1"> del segundo payload.</span>

<a id="t.3c9232b2d5d9ea2a259f8403ad80b64e9db35916"></a><a id="t.30"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 462.67px;">![image39](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/b479ae7e-2e92-4740-9d2a-98e2b9e2b5de)
</span>

</td>

</tr>

</tbody>

</table>

<span class="c2"></span>

<span class="c1">Ejecutamos el programa en el GUEST y desde WinDBG nos ponemos en el contexto del proceso para hacer un volcado de la dirección del espacio reservado:</span>

<a id="t.3c9232b2d5d9ea2a259f8403ad80b64e9db35916"></a><a id="t.31"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 564.87px; height: 107.00px;">![image40](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/43de80d5-e6f3-49ad-8fc5-5d4abc67d327)
</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span>Tenemos nuestro espacio reservado y los NOP´s escritos en la dirección virtual</span> <span class="c3">0x18000</span><span class="c1">:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 125.33px;">![image41](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/f44f5129-12c0-4ed0-b4e8-a3fce409cf2f)
</span>

<span>En este punto de la ejecución, nos encontramos con los permisos en</span> <span class="c3">PAGE_READONLY</span><span>después de ejecutar</span> <span class="c3">VirtualProtect()</span><span class="c1">, podemos comprobarlo mediante el comando !pte:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 68.00px;">![image42](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/08f24be4-f928-44f4-a3b0-8c0cd6930ab1)
</span>

<span class="c1">Cada estructura de paginación nos proporciona unos flags de control, en nuestro caso solo nos interesan los de la Page Table Entry:</span>

*   <span class="c3">BIT 1</span><span>→</span> <span class="c20">READ/WRITE</span>
*   <span class="c3">BIT 2</span><span>→</span> <span class="c20">USER/SUPERUSER</span>
*   <span class="c3">BIT 61 →</span> <span class="c20">NX (NO EXECUTE)</span>

<span class="c1"></span>

<a id="t.afdd9983bdd629f239192b064f00092a101090f8"></a><a id="t.32"></a>

<table class="c72">

<tbody>

<tr class="c14">

<td class="c18" colspan="1" rowspan="1">

<span class="c13 c3">P</span>

</td>

<td class="c45" colspan="1" rowspan="1">

<span class="c1">Present</span>

</td>

<td class="c85" colspan="1" rowspan="1">

<span class="c13 c3">G</span>

</td>

<td class="c58" colspan="1" rowspan="1">

<span class="c1">Global</span>

</td>

</tr>

<tr class="c14">

<td class="c18" colspan="1" rowspan="1">

<span class="c13 c3">R/W</span>

</td>

<td class="c45" colspan="1" rowspan="1">

<span class="c1">Read/Write</span>

</td>

<td class="c85" colspan="1" rowspan="1">

<span class="c13 c3">AVL</span>

</td>

<td class="c58" colspan="1" rowspan="1">

<span class="c1">Available</span>

</td>

</tr>

<tr class="c14">

<td class="c18" colspan="1" rowspan="1">

<span class="c13 c3">U/S</span>

</td>

<td class="c45" colspan="1" rowspan="1">

<span class="c1">User/Supervisor</span>

</td>

<td class="c85" colspan="1" rowspan="1">

<span class="c13 c3">PAT</span>

</td>

<td class="c58" colspan="1" rowspan="1">

<span class="c1">Page Attribute</span>

</td>

</tr>

<tr class="c14">

<td class="c18" colspan="1" rowspan="1">

<span class="c13 c3">PWT</span>

</td>

<td class="c45" colspan="1" rowspan="1">

<span class="c1">Write-Through Table</span>

</td>

<td class="c85" colspan="1" rowspan="1">

<span class="c13 c3">M</span>

</td>

<td class="c58" colspan="1" rowspan="1">

<span class="c1">Maximum</span>

</td>

</tr>

<tr class="c14">

<td class="c18" colspan="1" rowspan="1">

<span class="c13 c3">PCD</span>

</td>

<td class="c45" colspan="1" rowspan="1">

<span class="c1">Cache Disable</span>

</td>

<td class="c85" colspan="1" rowspan="1">

<span class="c13 c3">PK</span>

</td>

<td class="c58" colspan="1" rowspan="1">

<span class="c1">Protection Key</span>

</td>

</tr>

<tr class="c14">

<td class="c18" colspan="1" rowspan="1">

<span class="c13 c3">A</span>

</td>

<td class="c45" colspan="1" rowspan="1">

<span class="c1">Accessed</span>

</td>

<td class="c85" colspan="1" rowspan="1">

<span class="c13 c3">D</span>

</td>

<td class="c58" colspan="1" rowspan="1">

<span class="c1">Dirty</span>

</td>

</tr>

<tr class="c14">

<td class="c18" colspan="1" rowspan="1">

<span class="c13 c3">PS</span>

</td>

<td class="c45" colspan="1" rowspan="1">

<span class="c1">Page Size</span>

</td>

<td class="c85" colspan="1" rowspan="1">

<span class="c13 c3">XD</span>

</td>

<td class="c58" colspan="1" rowspan="1">

<span class="c1">Execute Disable</span>

</td>

</tr>

</tbody>

</table>

<span class="c1">Comprobamos traduciendo a binario el contenido de esta Page Table, si el segundo bit se encuentra desactivado significa que solo es de lectura:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 82.67px;">![image43](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/8160fb9a-fc95-44d0-952b-5856f67ea67b)
</span>

<span>Activamos ese BIT y sobre-escribimos el puntero que contiene la dirección de nuestro PTE en</span> <span class="c3">FFFFDA8000000C00</span><span class="c1">:</span>

<a id="t.5104ad600354398e324c287c67f201d6f550f49b"></a><a id="t.33"></a>

<table class="c78">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 105.33px;">![image44](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/ee5ed002-f8ab-480c-8a85-db8e477bf1a5)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 7-2\.  Activamos el bit 2 {READ} en binario</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 137.33px;">![image34](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/1d116775-f960-427f-9693-ff0151b6c956)
</span>

<span>Conseguiremos escribir en ese espacio de memoria? Continuamos con la ejecución del programa en RING3 y volvamos a hacer un volcado de esa dirección, deberíamos tener un slide de</span> <span class="c3">'\x00'</span><span class="c1">:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 185.33px;">![image25](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/5dc92909-bd52-4afb-b8af-7fc31c5358c5)
</span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3">6.2 SUBVERSIÓN DE LA MEMORIA</span>

<span>Si bien existen varias técnicas que nos permiten ocultar partes seleccionadas de la memoria de un proceso en la aplicación de espacio de usuario, solo hablare de una ellas que será la que implementaremos en nuestro driver será el</span> <span class="c12">“PTE REMAPING”</span><span class="c1">.</span>

<span class="c1">Qué es lo que conseguimos con esta técnica? Antes hemos visto que una entrada PTE contiene un marco de página llamado pfn, que sin entrar en detalles básicamente los PTE obtienen el pfn para la siguiente estructura de paginación, por los tanto en un contexto de x64 donde las páginas físicas son de 4096 bytes es decir 0x1000, y multiplicando ese pfn por el tamaño de la página física nos daría una dirección de memoria física!!</span>

<span class="c1">Comprobemos que es cierto en WinDBG y dentro del contexto del programa del ejemplo anterior, tenemos una shellcode de '\x00' cargada en la dirección 0x18000:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 69.33px;">![image26](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/233c59ff-8bbc-494a-bc99-e927d415ce35)
</span>

*   <span>Extraemos el marco de página de PTE y lo multiplicamos por</span> <span class="c9">0x1000</span>

*   <span class="c9">0x1a2f7e</span><span class="c1"> → dirección física</span>
*   <span class="c9">0x18000</span><span class="c1"> → dirección virtual</span>

<span class="c1">Realizando un dumpeo de las 2 direcciones deberíamos obtener los mismos datos, ya que en realidad estaríamos accediendo al mismo espacio físico, bien mediante traducción o bien de forma directa.</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 232.00px;">![image27](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/fe262d17-55b9-4060-bfdd-02e5e57ef15f)
</span>

<span class="c1">Por lo tanto, realmente podemos calcular la página física de la dirección virtual en tiempo de ejecución, y si aprovechamos para que el marco de página de la PTE de 2 direcciones virtuales diferentes apuntarán al mismo pfn??:</span>

*   <span class="c8 c29">Reservamos 2 espacios de memoria en user</span>
*   <span class="c8 c29">En uno de ellos lo rellenamos de nuestro payload y en el otro de código benigno</span>
*   <span class="c8 c29">Desde el driver obtenemos los correspondientes pfn de las PTE de las VA</span>
*   <span class="c8 c29">Y sobre-escribimos para el pfn de la página con el payload por el pfn del código benigno</span>

<span class="c13 c3"></span>

<a id="t.4d7cf209679717e57c0f86f52ccad89370b2bee7"></a><a id="t.34"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 210.67px;">![image28](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/2b19648c-5275-4ec8-9c3c-777fb4bf2c65)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 6.2-1\.  Diagrama Subversión de la memoria</span>

</td>

</tr>

</tbody>

</table>

<span class="c13 c3"></span>

<span class="c1">Trato de explicar en el diagrama anterior como sería la técnica que tratamos, de tal forma que “des-referenciamos” esa página física de su PTE, lo cual requerirá el recuperarla cuando se quiera acceder a ella.</span>

<span class="c13 c3"></span>

<span class="c13 c3">6.3 DRIVER</span>

<span class="c1">Lo primero que haremos es reservar memoria para escribir nuestra shellcode en memoria y reservar otro espacio de memoria de las mismas características con un sleed de 0x42 como zona de memoria benigna, después obtendremos la PTE con su PFN correspondiente de la misma forma que explique con el diagrama del punto 2 del write.</span>

<span>Si bien existe una API en</span> <span class="c12">nstoskrnl.exe</span><span>llamada</span> <span class="c12 c3">nt!MiGetPteAddress</span><span class="c1"> que en el desplazamiento 0x13 contiene la base de los PTE:</span>

<span class="c13 c3"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 109.33px;">![image29](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/f248341f-2f72-45c7-9dce-80669a3466d9)
</span>

<span class="c1">Nosotros llegaremos extrayendo el valor CR3 del EPROCESS y escalando hasta PTE:</span>

*   <span class="c38 c20 c3">PML4E → PDPT → PD → PDE → PTE [PFN]</span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3">6.4 FASE 1</span>

<span class="c1">Reservamos 2 espacios en memoria en uno de ellos escribimos la shellcode descifrada y en el otro lo rellenamos de 0x42\. Obtenemos la dirección virtual de la shellcode del tamaño 0x1000 que en nuestro caso se reserva en 0x18000 y setemaos su PTE a 0000000000000000 , y la dirección de la memoria limpia en 0x19000 con un tamaño también de 0x1000</span>

<span class="c1"></span>

<a id="t.b283d2e07fa888f73b059d66cbe8d0146e3ad750"></a><a id="t.35"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 208.00px;">![image30](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/b378b497-3bb7-4382-866d-e58e4dde6de2)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c47 c12 c74">Figura 6.4-1\. Contenido PTE seteado a 0</span><span class="c12 c29 c66">0000000000000000</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span>Intento representar en el diagrama la primera fase, recordar que el PFN de la PTE multiplicado por</span> <span class="c3">0x1000</span><span class="c1"> nos devuelve la dirección física real de tal forma que podemos volcar el contenido y mostramos con windbg:</span>

*   <span class="c20 c3">0x18000</span> <span class="c20">→ (0x6a1cb*0x1000) =</span> <span class="c3">DIR.FISICA</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 282.67px;">![image31](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/ec37ebcd-09f9-4671-87d3-9615f8038abb)
</span>

<span>Podemos observar como el volcado de la dirección física</span> <span class="c3">0x6a1cb000</span><span>que es la dirección virtual</span> <span class="c3">0x18000</span><span>contiene la shellcode descifrada con la clave</span> <span class="c3">RajKit</span><span class="c1"> mediante XOR, lo podemos ver en el debugger en el mapa de memoria:</span>

*   <span class="c38 c20 c3">shellcode[i]^[RajKit(i)]</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 297.33px;">![image32](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/60f70ae8-688a-4be9-bfac-600c13e6720c)
</span>

<span class="c13 c3">6.5 FASE 2</span>

<span class="c1">En la segunda fase asignamos un PFN a la PTE de la dirección virtual que apunta a la página que contiene código benigno 0x42 y mantendremos oculta la shellcode:</span>

<span class="c2"></span>

<a id="t.9a670a304141d053f6fc27f4caeda47b6c82045f"></a><a id="t.36"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 200.00px;">![image33](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/1597695f-d647-43ea-b7bf-51d3728f5cfd)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 6.5-1\. Seteamos el contenido de PTE y PFN para ocultar la shellcode</span>

</td>

</tr>

</tbody>

</table>

<span>Lo vemos desde el windbg como el volcado del</span> <span class="c3">PFN 0x35815</span><span>que en realidad es la dirección física</span> <span class="c3">0x35815000</span><span class="c1"> no contiene la shellcode:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 54.67px;">![image22](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/6432abc8-3661-45e8-8449-28852235026a)
</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 114.67px;">![image23](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/1c08029c-ccf6-4992-aca8-dcf06443f237)
</span>

<span>Vemos como volcamos la dirección virtual de la shellcode que si obtenemos su PFN nos devuelve la PTE y si traducimos esa PTE nos devuelve la dirección</span> <span class="c3">0x18000</span><span> que a su vez haciendo el volcado en realidad contiene un sleep de “</span><span class="c3">0x42</span><span class="c1">”:</span>

<span class="c2"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 346.67px;">![image59](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/da925293-d448-4dee-9559-39bc23d0f02d)
</span>

<span class="c13 c3">6.6 FASE 3</span>

<span class="c1">En la fase 3 revertimos la ocultación de la shellcode, apuntaremos con un hilo de ejecución para ejecutarla y volvemos a ocultar en la memoria de la misma forma</span>

<span class="c2"></span>

<a id="t.0bc384653696baa0338086cb4d73560c311f180e"></a><a id="t.37"></a>

<table class="c7">

<tbody>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.00px; height: 226.67px;">![image60](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/595b8a26-be42-4d35-80fe-e7b782c34bab)
</span>

</td>

</tr>

<tr class="c14">

<td class="c10" colspan="1" rowspan="1">

<span class="c4">Figura 6.6-1\. Reversión de la ocultación para posterior ejecución de shellcode</span>

</td>

</tr>

</tbody>

</table>

<span class="c2"></span>

<span class="c2"></span>

<span class="c2"></span>

<span>Esto nos ejecutara una shellcode que abrirá</span> <span class="c12">calc.exe</span><span class="c1"> para después volver a ocultarla:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 398.67px;">![image61](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/4f2caa9d-9f45-47c1-9811-50d78f60ce06)
</span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c13 c3"></span>

<span class="c3 c13">7\. KERNEL EXCEPTION HOOKING</span>

<span>Como punto extra introduzco un reversing y posterior evasión de</span> <span class="c12">Kernel Patch Protection</span> <span class="c1">mediante una técnica llamada Kernel Exception Hooking, que comencé explicando en el punto 2 de este trabajo continuamos:</span>

<span class="c12 c3">KiExceptionDispatch</span><span>y</span> <span class="c12 c3">KiBugCheckDispatch</span><span>van rellenando una estructura</span> <span class="c34 c59">[KEXCEPTION_FRAME](https://www.google.com/url?q=https://www.vergiliusproject.com/kernels/x64/Windows%252011/21H2%2520(RTM)/_KEXCEPTION_FRAME&sa=D&source=editors&ust=1709480026325480&usg=AOvVaw2lLqHeFb1j_QnZ33DRx54P)</span><span class="c1">, guardando los registros volátiles.</span>

<span>Nos centraremos en el reversing de</span> <span class="c12">ntoskrnl.exe</span><span>a partir de</span> <span class="c12 c3">KeBugCheckEx</span> <span>y</span><span class="c3"> </span><span class="c12 c3">KeBugCheck2</span><span>que comienza deshabilitando las interrupciones, guardando el contexto de la llamada y el estado del procesador para pasar directamente el control a</span> <span class="c12 c3">KeBugCheck2</span><span class="c12">:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 501.53px; height: 294.00px;">![image62](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/d25359e8-5940-4c0c-bbee-80bda057aa09)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span>Se guarda completamente el contexto de la ejecución antes de la excepción</span> <span class="c12 c3">(RtlCaptureContext)</span><span class="c1">:</span>

<a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.38"></a>

<table class="c78">

<tbody>

<tr class="c14">

<td class="c68" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 286.00px; height: 280.00px;">![image63](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/97fa5ca9-eb3b-4524-b645-90f61053e3ac)
</span>

</td>

<td class="c68" colspan="1" rowspan="1">

<span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 286.00px; height: 356.00px;">![image64](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/24ca9139-06b9-442c-b641-f316d96fc95f)
</span>

</td>

</tr>

</tbody>

</table>

<span class="c1"></span>

<span class="c21">El bit de característica 0x00020000 para Windows de 64 bits tiene el nombre de lenguaje ensamblador conocido</span> <span class="c3 c21">KF_BRANCH</span><span class="c21">. Está configurado para procesadores que el kernel reconoce que tienen registros específicos del modelo para mantener un registro de última rama (LBR).</span> <span class="c34 c12 c21 c59">[PRCB](https://www.google.com/url?q=https://learn.microsoft.com/es-es/windows-hardware/drivers/debugger/-prcb&sa=D&source=editors&ust=1709480026326929&usg=AOvVaw28TtNFN-H7aihrTfPjjNS9)</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 196.00px;">![image65](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/3d8154a9-a043-4571-b8f3-c47dc499d280)
</span>

<span>El sistema operativo habilita la función de ramificación para tareas del kernel (por ejemplo, después de un BSOD causado por algún controlador, puede obtener</span> <span class="c3">LastBranchFrom</span><span>/ To del archivo de volcado de fallas). Si dicha tarea interrumpe su grabación e intenta continuar grabando después de reprogramar su tarea, tendrá un</span> <span class="c3">MSR_LASTBRANCH_TOS</span><span>diferente:</span> <span class="c12 c3">(KiSaveProcessorControlState)</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 241.33px;">![image66](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/8930e071-5610-4de3-b80c-97c1955373f4)
</span>

<span class="c1"></span>

<span>Después</span> <span class="c12 c3">KeBugCheckEx</span><span>incrementa</span> <span class="c12 c3">KiHardwareTrigger</span><span>y cede el control a</span> <span class="c12 c3">KeBugCheck2:</span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 178.67px;">![image59](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/409c9c4f-7775-4fa6-804b-3b58000da462)
</span>

<span>Una vez en</span> <span class="c12 c3">KeBugCheck2</span><span class="c1">:</span>

<span class="c8 c29"></span>

*   <span class="c8 c29">Prepara y escribe la información del crashdump</span>
*   <span class="c8 c29">Congela la ejecución en las CPU</span>
*   <span class="c12 c3 c61">KiDisplayBluescreen</span>
*   <span class="c8 c29">Reinicio</span>

<span>Recibimos 4 argumentos, el primero de ellos</span> <span class="c34 c12 c3 c59">[BugCheckCode](https://www.google.com/url?q=https://www.geoffchappell.com/studies/windows/km/bugchecks/index.htm&sa=D&source=editors&ust=1709480026327999&usg=AOvVaw2RgWt1c_VzKsXNTzauOwdr)</span><span class="c1">, a partir del cual se realizan varias comprobaciones en función del código:</span>

<span class="c1"></span>

<span class="c3">v11</span><span class="c9 c3"> = *&BugCheckCode</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 48.00px;">![image57](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/7f046a1a-a6b2-45b4-8bef-b40010e275c3)
</span>

<span class="c1"></span>

<span class="c1">Recibimos en v66 el argumento 1:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 85.33px;">![image59](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/1f81303d-1624-4347-9cc0-f315d695ed46)
</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 101.33px;">![image49](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/cfe7e7f3-e820-442e-9643-9360f499d319)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span>Comprueba si estamos bajo</span> <span class="c3">Hyper-V</span><span class="c1">:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 198.67px;">![image50](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/279e6adf-28f2-4481-8c6a-a312307176d8)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span>Comprobaciones</span> <span class="c34 c59">[NMI](https://www.google.com/url?q=https://learn.microsoft.com/es-es/troubleshoot/windows-client/performance/nmi-hardware-failure-error&sa=D&source=editors&ust=1709480026329451&usg=AOvVaw3zhnTVSgNBRffASDTjz4pp)</span><span class="c1"> :</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 121.33px;">![image51](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/dae490a4-cea0-439c-87b6-d1c8dfcfe876)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span>Se verifican los proceso congelados con</span><span class="c12"> </span><span class="c12 c3">IoInitilizeBugCheckProcess</span><span class="c3"> </span><span>desde</span><span class="c12 c3"> KeBugCheck2</span><span class="c3">:</span>

<span class="c13 c3"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 356.00px;">![image52](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/ba252742-ca18-4249-8acf-3bbe7a1b3c6a)
</span>

<span class="c1"></span>

<span>Se llama a</span> <span class="c12 c3">KiDisplayBlueScreen</span><span class="c1"> para mostrar el famoso pantallazo azul BSOD:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 434.67px;">![image53](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/e91f2f7e-3bf2-42eb-8d44-ed15e1885aac)
</span>

<span>Reinicio del sistema</span> <span class="c12 c3">HalReturnToFirmware</span><span class="c1">:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.13px; height: 77.00px;">![image54](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/bea8245f-42bf-49d2-8884-ff2a8a6d3ab9)
</span>

<span class="c1"></span>

<span>En</span> <span class="c12 c3">Hal.dll</span> <span>desensamblando vemos</span> <span class="c3">HalPrivateDispatchTable</span><span> </span><span class="c12">(que se encuentra en la sección .idata lejos de KPP)</span><span>obtendremos así la dirección de la tabla</span> <span class="c34 c59">[HALL_DISPATCH](https://www.google.com/url?q=https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/hal/hal_dispatch.htm&sa=D&source=editors&ust=1709480026330801&usg=AOvVaw1fF0cJ32o1DhduTsNimXPf)</span><span>que es la que contiene punteros a las funciones que implementa</span> <span class="c12">HAL.DLL</span> <span class="c1">y necesitamos enganchar:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 68.00px;">![image55](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/17cad60f-8d8f-4a04-8448-295bad7785d1)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span>Se hace un hook a</span> <span class="c3">HalPrepareForBugcheck</span><span class="c1">:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 190.67px;">![image45](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/1d6a905b-c253-453f-825f-be83c981eb2b)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span>Se extrae el contexto de la rutina interrumpida por</span> <span class="c12 c3">KeBugCheck2:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 210.67px;">![image46](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/fa4d5b59-e064-4464-b771-3522d131f9b7)
</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 96.00px;">![image47](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/e9325f98-9301-42cf-a777-5e8d3ea3066d)
</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 384.00px;">![image48](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/dece423f-82d0-4b45-a31f-a44afbe4b467)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1">Probamos el driver realizando el HOOK:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 340.00px;">![image83](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/7c2bbe2c-d091-4034-8d10-b18c563439fb)
</span>

<span class="c1"></span>

<span class="c1">Interceptamos y no vemos BSOD:</span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 472.00px;">![image85](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/443a091b-dfad-404f-b275-a166f6954582)
</span>

<span class="c1">Sin HOOK:</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 122.67px;">![image87](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/c11f1267-d5b6-4254-8439-87da205b0e40)
</span>

<span class="c1"></span>

<span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 2.67px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.87px; height: 116.00px;">![image89](https://github.com/kdRajKit/RAJKIT-MALWARE-DRIVER-USER/assets/108155637/bc5e7807-2ffb-466c-bca4-d82c37502698)
</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">8\. CONCLUSIÓN</span>

<span class="c1">Hoy en día es indispensable para las grandes empresas y gobiernos contar con la ayuda de simulaciones de ataques, para aprender de ellos y desarrollar mitigaciones lo más robustas posibles, desde las empresas, contar con este tipo de artefactos y técnicas permite que los equipos involucrados en evaluar las defensas y posibles ataques puedan prepararse y anticipar ataques de este calado.</span>

<span class="c1">Desde mi punto de vista creo que no hay mejor forma de implementar esas mitigaciones que  desarrollando herramientas como la que presentó enfocando el desarrollo desde el punto de vista lo más cercano posible a las grandes organizaciones de extorsión, espionaje industrial y gubernamental.</span>

<span>Por ello investigar los entresijos técnicos de los sistemas y aprender de su comportamiento es vital para el desarrollo de herramientas como</span> <span class="c3">RajKit</span><span class="c1"> para tratar de descubrir técnicas que ni siquiera se conozcan actualmente y anteponerse a estos ataques mediante mitigaciones complejas y sigilosas.</span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c1"></span>

<span class="c13 c3">9\. BIBLIOGRAFÍA</span>

<span class="c34">[https://www.iberlibro.com/9781449626365/ROOTKIT-ARSENAL-ESCAPE-EVASION-DARK-144962636X/plp](https://www.google.com/url?q=https://www.iberlibro.com/9781449626365/ROOTKIT-ARSENAL-ESCAPE-EVASION-DARK-144962636X/plp&sa=D&source=editors&ust=1709480026333354&usg=AOvVaw2U54HaDocPmED197h0lhlR)</span>

<span class="c34">[https://dl.ebooksworld.ir/motoman/No.Starch.Press.Rootkits.and.Bootkits.www.EBooksWorld.ir.pdf](https://www.google.com/url?q=https://dl.ebooksworld.ir/motoman/No.Starch.Press.Rootkits.and.Bootkits.www.EBooksWorld.ir.pdf&sa=D&source=editors&ust=1709480026333560&usg=AOvVaw278QaWpkx2Nix1GZw6HiWO)</span>

<span class="c34">[https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026333764&usg=AOvVaw1JHS6btg23YZ-V44NDglU4)</span>

<span class="c34">[https://books.google.es/books/about/Rootkits.html?id=fDxg1W3eT2gC&redir_esc=y](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026333956&usg=AOvVaw3GucyDpPPeyXmYdi10wsq2)</span>

<span class="c34">[https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026334164&usg=AOvVaw0F11ujkqT1iSqPFll2Xq9m)</span>

<span class="c34">[https://rvsec0n.wordpress.com/2019/09/13/routines-utilizing-tebs-and-pebs/](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026334371&usg=AOvVaw36ikAtoo-zWLwZ4tTejfBG)</span>

<span class="c34">[https://calcifer.org/documentos/librognome/glib-lists-queues.html](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026334573&usg=AOvVaw2ys_gx5ma3sZqB4mBCih-g)</span>

<span class="c34">[https://learn.microsoft.com/es-es/cpp/build/x64-calling-convention?view=msvc-170](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026334767&usg=AOvVaw30Hs8Rn2n2BW5C6pDCksvG)</span>

<span class="c34">[https://github.com/jthuraisamy/SysWhispers2](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026334959&usg=AOvVaw0snj4MoPzZk-xpn09P5f83)</span>

<span class="c34">[https://github.com/can1357/ByePg](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026335162&usg=AOvVaw0Ou6wsQ8f0D2aPWgJbIRXr)</span>

<span class="c34">[https://learn.microsoft.com/es-es/troubleshoot/windows-client/performance/nmi-hardware-failure-error](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026335350&usg=AOvVaw1QEpxxbM1TFyyG7SoQM4uK)</span>

<span class="c34">[https://windows-internals.com/hyperguard-secure-kernel-patch-guard-part-1-skpg-initialization/](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026335539&usg=AOvVaw2t44raFMOP3e03E5d2mEeL)</span>

<span class="c34">[https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/kprcb/featurebits.htm](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026335730&usg=AOvVaw3Lz_Hl1zny4rffGwEwf2tS)</span>

<span class="c34">[https://learn.microsoft.com/es-es/troubleshoot/windows-server/performance/use-driver-verifier-to-identify-issues](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026335920&usg=AOvVaw0tGSeNoI3Par3_yvfoCkdo)</span>

<span class="c34">[https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/hal/hal_private_dispatch.htm](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026336115&usg=AOvVaw32Apf92KTJkWjgRY5x8VbL)</span>

<span class="c34">[https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/amd64_x/ktrap_frame.htm](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026336310&usg=AOvVaw3MFv8wXXb-Sp3Zf6EeVsSN)</span>

<span class="c34">[https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ktrap_frame.htm?tx=138&ts=0,4](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026336489&usg=AOvVaw2jNWzsmi3AC8flyQbmEpX3)</span>

<span class="c34">[https://www.geoffchappell.com/studies/windows/km/bugchecks/index.htm](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026336667&usg=AOvVaw2GtBnwNbJDkXmBGVyiE1aM)</span>

<span class="c34">[https://www.bleepingcomputer.com/forums/t/762974/bsod-using-windbg-windows-debugger-and-analyze-v/](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026336879&usg=AOvVaw3QnrRDpwcww2qupSWl-vB7)</span>

<span class="c34">[https://en.wikipedia.org/wiki/Deferred_Procedure_Call](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026337079&usg=AOvVaw0dP6iAtguOj9s83IYFaOd3)</span>

<span class="c34">[https://www.trendmicro.com/es_es/research/23/e/blackcat-ransomware-deploys-new-signed-kernel-driver.html](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026337278&usg=AOvVaw3XRpqhHgeSMQR--jVSF7P_)</span>

<span class="c34">[https://lsi.vc.ehu.eus/pablogn/docencia/manuales/SO/TemasSOuJaen/ADMINISTRACIONDELAMEMORIA/5.1 Paginacion.htm](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026337463&usg=AOvVaw3GKjzVJAsxN5tyboIRqO2p)</span>

<span class="c34">[https://www.microsoft.com/en-us/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-platform- security-technology-for-preventing-data-corruption/](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026337639&usg=AOvVaw361mqymXHnx8dT701QeQ5k)</span>

<span class="c34">[https://empyreal96.github.io/nt-info-depot/Windows-Internals-PDFs/WindowsSystemInternalPart1.pdf](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026337818&usg=AOvVaw2tfo3N6R4ZvSJiKbNU0IUu)</span>

<span class="c34">[https://stackoverflow.com/questions/35670045/accessing-user-mode-memory-inside-kernel-mode-driver](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026338000&usg=AOvVaw1fnoyKTiZiBIC-2wdJNipt)</span>

<span class="c34">[https://github.com/TheCruZ/kdmapper](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026338200&usg=AOvVaw34Ed0DNigpd1wBnvuJxrgQ)</span>

<span class="c34">[https://github.com/AzAgarampur/byeintegrity8-uac](https://www.google.com/url?q=https://github.com/AzAgarampur/byeintegrity8-uac&sa=D&source=editors&ust=1709480026338364&usg=AOvVaw1QnUAx9xlCBZ5VTcW-Qy3N)</span>

<span class="c34">[https://merlin-c2.readthedocs.io/en/latest/quickStart/agent.html](https://www.google.com/url?q=https://www.amazon.es/Practical-Reverse-Engineering-Reversing-Obfuscation-ebook/dp/B00IA22R2Y&sa=D&source=editors&ust=1709480026338537&usg=AOvVaw0eMBkgKva6VcV-v8SSxG9F)</span>

<span class="c1"></span>

<span class="c1"></span>

<div>

<span class="c1"></span>

</div>
